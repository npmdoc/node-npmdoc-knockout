<html><head></head><body><div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a href="http://knockoutjs.com/">knockout (v3.4.2)</a>
</h1>
<h4>Knockout makes it easier to create rich, responsive UIs with JavaScript</h4>
<div class="apidocSectionDiv"><a href="#apidoc.tableOfContents" id="apidoc.tableOfContents"><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.knockout">module knockout</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.__tr_ambtns">
            function <span class="apidocSignatureSpan">knockout.</span>__tr_ambtns
            <span class="apidocSignatureSpan">(bindings, nodeName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.applyBindingAccessorsToNode">
            function <span class="apidocSignatureSpan">knockout.</span>applyBindingAccessorsToNode
            <span class="apidocSignatureSpan">(node, bindings, viewModelOrBindingContext)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.applyBindings">
            function <span class="apidocSignatureSpan">knockout.</span>applyBindings
            <span class="apidocSignatureSpan">(viewModelOrBindingContext, rootNode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.applyBindingsToDescendants">
            function <span class="apidocSignatureSpan">knockout.</span>applyBindingsToDescendants
            <span class="apidocSignatureSpan">(viewModelOrBindingContext, rootNode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.applyBindingsToNode">
            function <span class="apidocSignatureSpan">knockout.</span>applyBindingsToNode
            <span class="apidocSignatureSpan">(node, bindings, viewModelOrBindingContext)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.bindingContext">
            function <span class="apidocSignatureSpan">knockout.</span>bindingContext
            <span class="apidocSignatureSpan">(dataItemOrAccessor, parentContext, dataItemAlias, extendCallback, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.bindingProvider">
            function <span class="apidocSignatureSpan">knockout.</span>bindingProvider
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.cleanNode">
            function <span class="apidocSignatureSpan">knockout.</span>cleanNode
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.computed">
            function <span class="apidocSignatureSpan">knockout.</span>computed
            <span class="apidocSignatureSpan">(evaluatorFunctionOrOptions, evaluatorFunctionTarget, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.contextFor">
            function <span class="apidocSignatureSpan">knockout.</span>contextFor
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.dataFor">
            function <span class="apidocSignatureSpan">knockout.</span>dataFor
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.dependentObservable">
            function <span class="apidocSignatureSpan">knockout.</span>dependentObservable
            <span class="apidocSignatureSpan">(evaluatorFunctionOrOptions, evaluatorFunctionTarget, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.exportProperty">
            function <span class="apidocSignatureSpan">knockout.</span>exportProperty
            <span class="apidocSignatureSpan">(owner, publicName, object)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.exportSymbol">
            function <span class="apidocSignatureSpan">knockout.</span>exportSymbol
            <span class="apidocSignatureSpan">(koPath, object)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.getBindingHandler">
            function <span class="apidocSignatureSpan">knockout.</span>getBindingHandler
            <span class="apidocSignatureSpan">(bindingKey)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.hasPrototype">
            function <span class="apidocSignatureSpan">knockout.</span>hasPrototype
            <span class="apidocSignatureSpan">(instance, prototype)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.ignoreDependencies">
            function <span class="apidocSignatureSpan">knockout.</span>ignoreDependencies
            <span class="apidocSignatureSpan">(callback, callbackTarget, callbackArgs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.isComputed">
            function <span class="apidocSignatureSpan">knockout.</span>isComputed
            <span class="apidocSignatureSpan">(instance)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.isObservable">
            function <span class="apidocSignatureSpan">knockout.</span>isObservable
            <span class="apidocSignatureSpan">(instance)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.isPureComputed">
            function <span class="apidocSignatureSpan">knockout.</span>isPureComputed
            <span class="apidocSignatureSpan">(instance)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.isSubscribable">
            function <span class="apidocSignatureSpan">knockout.</span>isSubscribable
            <span class="apidocSignatureSpan">(instance)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.isWritableObservable">
            function <span class="apidocSignatureSpan">knockout.</span>isWritableObservable
            <span class="apidocSignatureSpan">(instance)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.isWriteableObservable">
            function <span class="apidocSignatureSpan">knockout.</span>isWriteableObservable
            <span class="apidocSignatureSpan">(instance)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.jqueryTmplTemplateEngine">
            function <span class="apidocSignatureSpan">knockout.</span>jqueryTmplTemplateEngine
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.nativeTemplateEngine">
            function <span class="apidocSignatureSpan">knockout.</span>nativeTemplateEngine
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.observable">
            function <span class="apidocSignatureSpan">knockout.</span>observable
            <span class="apidocSignatureSpan">(initialValue)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.observableArray">
            function <span class="apidocSignatureSpan">knockout.</span>observableArray
            <span class="apidocSignatureSpan">(initialValues)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.pureComputed">
            function <span class="apidocSignatureSpan">knockout.</span>pureComputed
            <span class="apidocSignatureSpan">(evaluatorFunctionOrOptions, evaluatorFunctionTarget)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.removeNode">
            function <span class="apidocSignatureSpan">knockout.</span>removeNode
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.renderTemplate">
            function <span class="apidocSignatureSpan">knockout.</span>renderTemplate
            <span class="apidocSignatureSpan">(template, dataOrBindingContext, options, targetNodeOrNodeArray, renderMode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.renderTemplateForEach">
            function <span class="apidocSignatureSpan">knockout.</span>renderTemplateForEach
            <span class="apidocSignatureSpan">(template, arrayOrObservableArray, options, targetNode, parentBindingContext)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.setTemplateEngine">
            function <span class="apidocSignatureSpan">knockout.</span>setTemplateEngine
            <span class="apidocSignatureSpan">(templateEngine)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.storedBindingContextForNode">
            function <span class="apidocSignatureSpan">knockout.</span>storedBindingContextForNode
            <span class="apidocSignatureSpan">(node, bindingContext)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.subscribable">
            function <span class="apidocSignatureSpan">knockout.</span>subscribable
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.subscription">
            function <span class="apidocSignatureSpan">knockout.</span>subscription
            <span class="apidocSignatureSpan">(target, callback, disposeCallback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.templateEngine">
            function <span class="apidocSignatureSpan">knockout.</span>templateEngine
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.templateSources.anonymousTemplate">
            function <span class="apidocSignatureSpan">knockout.</span>templateSources.anonymousTemplate
            <span class="apidocSignatureSpan">(element)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.templateSources.domElement">
            function <span class="apidocSignatureSpan">knockout.</span>templateSources.domElement
            <span class="apidocSignatureSpan">(element)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.toJS">
            function <span class="apidocSignatureSpan">knockout.</span>toJS
            <span class="apidocSignatureSpan">(rootObject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.toJSON">
            function <span class="apidocSignatureSpan">knockout.</span>toJSON
            <span class="apidocSignatureSpan">(rootObject, replacer, space)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.unwrap">
            function <span class="apidocSignatureSpan">knockout.</span>unwrap
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">knockout.</span>bindingContext.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">knockout.</span>bindingHandlers</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">knockout.</span>bindingProvider.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">knockout.</span>components</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">knockout.</span>components.defaultLoader</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">knockout.</span>computedContext</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">knockout.</span>dependencyDetection</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">knockout.</span>dependentObservable.fn</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">knockout.</span>expressionRewriting</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">knockout.</span>expressionRewriting.bindingRewriteValidators</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">knockout.</span>extenders</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">knockout.</span>jqueryTmplTemplateEngine.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">knockout.</span>jsonExpressionRewriting</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">knockout.</span>memoization</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">knockout.</span>nativeTemplateEngine.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">knockout.</span>options</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">knockout.</span>selectExtensions</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">knockout.</span>subscription.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">knockout.</span>tasks</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">knockout.</span>templateEngine.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">knockout.</span>templateRewriting</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">knockout.</span>templateSources</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">knockout.</span>templateSources.anonymousTemplate.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">knockout.</span>templateSources.domElement.prototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">knockout.</span>utils</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">knockout.</span>utils.domData</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">knockout.</span>utils.domNodeDisposal</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">knockout.</span>virtualElements</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">knockout.</span>version</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.knockout.bindingContext">module knockout.bindingContext</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.bindingContext.bindingContext">
            function <span class="apidocSignatureSpan">knockout.</span>bindingContext
            <span class="apidocSignatureSpan">(dataItemOrAccessor, parentContext, dataItemAlias, extendCallback, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.knockout.bindingContext.prototype">module knockout.bindingContext.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.bindingContext.prototype.createChildContext">
            function <span class="apidocSignatureSpan">knockout.bindingContext.prototype.</span>createChildContext
            <span class="apidocSignatureSpan">(dataItemOrAccessor, dataItemAlias, extendCallback, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.bindingContext.prototype.createStaticChildContext">
            function <span class="apidocSignatureSpan">knockout.bindingContext.prototype.</span>createStaticChildContext
            <span class="apidocSignatureSpan">(dataItemOrAccessor, dataItemAlias)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.bindingContext.prototype.extend">
            function <span class="apidocSignatureSpan">knockout.bindingContext.prototype.</span>extend
            <span class="apidocSignatureSpan">(properties)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.knockout.bindingProvider">module knockout.bindingProvider</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.bindingProvider.bindingProvider">
            function <span class="apidocSignatureSpan">knockout.</span>bindingProvider
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">knockout.bindingProvider.</span>instance</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.knockout.bindingProvider.prototype">module knockout.bindingProvider.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.bindingProvider.prototype.getBindingAccessors">
            function <span class="apidocSignatureSpan">knockout.bindingProvider.prototype.</span>getBindingAccessors
            <span class="apidocSignatureSpan">(node, bindingContext)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.bindingProvider.prototype.getBindings">
            function <span class="apidocSignatureSpan">knockout.bindingProvider.prototype.</span>getBindings
            <span class="apidocSignatureSpan">(node, bindingContext)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.bindingProvider.prototype.getBindingsString">
            function <span class="apidocSignatureSpan">knockout.bindingProvider.prototype.</span>getBindingsString
            <span class="apidocSignatureSpan">(node, bindingContext)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.bindingProvider.prototype.nodeHasBindings">
            function <span class="apidocSignatureSpan">knockout.bindingProvider.prototype.</span>nodeHasBindings
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.bindingProvider.prototype.parseBindingsString">
            function <span class="apidocSignatureSpan">knockout.bindingProvider.prototype.</span>parseBindingsString
            <span class="apidocSignatureSpan">(bindingsString, bindingContext, node, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.knockout.components">module knockout.components</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.components._getFirstResultFromLoaders">
            function <span class="apidocSignatureSpan">knockout.components.</span>_getFirstResultFromLoaders
            <span class="apidocSignatureSpan">(methodName, argsExceptCallback, callback, candidateLoaders)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.components.addBindingsForCustomElement">
            function <span class="apidocSignatureSpan">knockout.components.</span>addBindingsForCustomElement
            <span class="apidocSignatureSpan">(allBindings, node, bindingContext, valueAccessors)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.components.clearCachedDefinition">
            function <span class="apidocSignatureSpan">knockout.components.</span>clearCachedDefinition
            <span class="apidocSignatureSpan">(componentName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.components.get">
            function <span class="apidocSignatureSpan">knockout.components.</span>get
            <span class="apidocSignatureSpan">(componentName, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.components.getComponentNameForNode">
            function <span class="apidocSignatureSpan">knockout.components.</span>getComponentNameForNode
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.components.isRegistered">
            function <span class="apidocSignatureSpan">knockout.components.</span>isRegistered
            <span class="apidocSignatureSpan">(componentName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.components.register">
            function <span class="apidocSignatureSpan">knockout.components.</span>register
            <span class="apidocSignatureSpan">(componentName, config)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.components.unregister">
            function <span class="apidocSignatureSpan">knockout.components.</span>unregister
            <span class="apidocSignatureSpan">(componentName)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">knockout.components.</span>_allRegisteredComponents</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">knockout.components.</span>defaultLoader</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">knockout.components.</span>loaders</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.knockout.components.defaultLoader">module knockout.components.defaultLoader</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.components.defaultLoader.getConfig">
            function <span class="apidocSignatureSpan">knockout.components.defaultLoader.</span>getConfig
            <span class="apidocSignatureSpan">(componentName, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.components.defaultLoader.loadComponent">
            function <span class="apidocSignatureSpan">knockout.components.defaultLoader.</span>loadComponent
            <span class="apidocSignatureSpan">(componentName, config, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.components.defaultLoader.loadTemplate">
            function <span class="apidocSignatureSpan">knockout.components.defaultLoader.</span>loadTemplate
            <span class="apidocSignatureSpan">(componentName, templateConfig, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.components.defaultLoader.loadViewModel">
            function <span class="apidocSignatureSpan">knockout.components.defaultLoader.</span>loadViewModel
            <span class="apidocSignatureSpan">(componentName, viewModelConfig, callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.knockout.dependencyDetection">module knockout.dependencyDetection</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.dependencyDetection.begin">
            function <span class="apidocSignatureSpan">knockout.dependencyDetection.</span>begin
            <span class="apidocSignatureSpan">(options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.dependencyDetection.end">
            function <span class="apidocSignatureSpan">knockout.dependencyDetection.</span>end
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.dependencyDetection.getDependenciesCount">
            function <span class="apidocSignatureSpan">knockout.dependencyDetection.</span>getDependenciesCount
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.dependencyDetection.ignore">
            function <span class="apidocSignatureSpan">knockout.dependencyDetection.</span>ignore
            <span class="apidocSignatureSpan">(callback, callbackTarget, callbackArgs)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.dependencyDetection.isInitial">
            function <span class="apidocSignatureSpan">knockout.dependencyDetection.</span>isInitial
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.dependencyDetection.registerDependency">
            function <span class="apidocSignatureSpan">knockout.dependencyDetection.</span>registerDependency
            <span class="apidocSignatureSpan">(subscribable)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.knockout.dependentObservable">module knockout.dependentObservable</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.dependentObservable.dependentObservable">
            function <span class="apidocSignatureSpan">knockout.</span>dependentObservable
            <span class="apidocSignatureSpan">(evaluatorFunctionOrOptions, evaluatorFunctionTarget, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.dependentObservable.__ko_proto__">
            function <span class="apidocSignatureSpan">knockout.dependentObservable.</span>__ko_proto__
            <span class="apidocSignatureSpan">(initialValue)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">knockout.dependentObservable.</span>fn</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.knockout.dependentObservable.fn">module knockout.dependentObservable.fn</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.dependentObservable.fn.__ko_proto__">
            function <span class="apidocSignatureSpan">knockout.dependentObservable.fn.</span>__ko_proto__
            <span class="apidocSignatureSpan">(evaluatorFunctionOrOptions, evaluatorFunctionTarget, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.dependentObservable.fn.addDependencyTracking">
            function <span class="apidocSignatureSpan">knockout.dependentObservable.fn.</span>addDependencyTracking
            <span class="apidocSignatureSpan">(id, target, trackingObj)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.dependentObservable.fn.dispose">
            function <span class="apidocSignatureSpan">knockout.dependentObservable.fn.</span>dispose
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.dependentObservable.fn.equalityComparer">
            function <span class="apidocSignatureSpan">knockout.dependentObservable.fn.</span>equalityComparer
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.dependentObservable.fn.evaluateImmediate">
            function <span class="apidocSignatureSpan">knockout.dependentObservable.fn.</span>evaluateImmediate
            <span class="apidocSignatureSpan">(notifyChange)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.dependentObservable.fn.evaluateImmediate_CallReadThenEndDependencyDetection">
            function <span class="apidocSignatureSpan">knockout.dependentObservable.fn.</span>evaluateImmediate_CallReadThenEndDependencyDetection
            <span class="apidocSignatureSpan">(state, dependencyDetectionContext)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.dependentObservable.fn.evaluateImmediate_CallReadWithDependencyDetection">
            function <span class="apidocSignatureSpan">knockout.dependentObservable.fn.</span>evaluateImmediate_CallReadWithDependencyDetection
            <span class="apidocSignatureSpan">(notifyChange)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.dependentObservable.fn.evaluatePossiblyAsync">
            function <span class="apidocSignatureSpan">knockout.dependentObservable.fn.</span>evaluatePossiblyAsync
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.dependentObservable.fn.getDependenciesCount">
            function <span class="apidocSignatureSpan">knockout.dependentObservable.fn.</span>getDependenciesCount
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.dependentObservable.fn.haveDependenciesChanged">
            function <span class="apidocSignatureSpan">knockout.dependentObservable.fn.</span>haveDependenciesChanged
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.dependentObservable.fn.isActive">
            function <span class="apidocSignatureSpan">knockout.dependentObservable.fn.</span>isActive
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.dependentObservable.fn.limit">
            function <span class="apidocSignatureSpan">knockout.dependentObservable.fn.</span>limit
            <span class="apidocSignatureSpan">(limitFunction)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.dependentObservable.fn.markDirty">
            function <span class="apidocSignatureSpan">knockout.dependentObservable.fn.</span>markDirty
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.dependentObservable.fn.peek">
            function <span class="apidocSignatureSpan">knockout.dependentObservable.fn.</span>peek
            <span class="apidocSignatureSpan">(evaluate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.dependentObservable.fn.respondToChange">
            function <span class="apidocSignatureSpan">knockout.dependentObservable.fn.</span>respondToChange
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.dependentObservable.fn.subscribeToDependency">
            function <span class="apidocSignatureSpan">knockout.dependentObservable.fn.</span>subscribeToDependency
            <span class="apidocSignatureSpan">(target)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.knockout.expressionRewriting">module knockout.expressionRewriting</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.expressionRewriting.insertPropertyAccessorsIntoJson">
            function <span class="apidocSignatureSpan">knockout.expressionRewriting.</span>insertPropertyAccessorsIntoJson
            <span class="apidocSignatureSpan">(bindingsStringOrKeyValueArray, bindingOptions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.expressionRewriting.keyValueArrayContainsKey">
            function <span class="apidocSignatureSpan">knockout.expressionRewriting.</span>keyValueArrayContainsKey
            <span class="apidocSignatureSpan">(keyValueArray, key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.expressionRewriting.parseObjectLiteral">
            function <span class="apidocSignatureSpan">knockout.expressionRewriting.</span>parseObjectLiteral
            <span class="apidocSignatureSpan">(objectLiteralString)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.expressionRewriting.preProcessBindings">
            function <span class="apidocSignatureSpan">knockout.expressionRewriting.</span>preProcessBindings
            <span class="apidocSignatureSpan">(bindingsStringOrKeyValueArray, bindingOptions)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.expressionRewriting.writeValueToProperty">
            function <span class="apidocSignatureSpan">knockout.expressionRewriting.</span>writeValueToProperty
            <span class="apidocSignatureSpan">(property, allBindings, key, value, checkIfDifferent)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">knockout.expressionRewriting.</span>_twoWayBindings</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">knockout.expressionRewriting.</span>bindingRewriteValidators</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">knockout.expressionRewriting.</span>twoWayBindings</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.knockout.expressionRewriting.bindingRewriteValidators">module knockout.expressionRewriting.bindingRewriteValidators</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">knockout.expressionRewriting.bindingRewriteValidators.</span>foreach</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">knockout.expressionRewriting.bindingRewriteValidators.</span>if</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">knockout.expressionRewriting.bindingRewriteValidators.</span>ifnot</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">knockout.expressionRewriting.bindingRewriteValidators.</span>with</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.expressionRewriting.bindingRewriteValidators.template">
            function <span class="apidocSignatureSpan">knockout.expressionRewriting.bindingRewriteValidators.</span>template
            <span class="apidocSignatureSpan">(bindingValue)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.knockout.extenders">module knockout.extenders</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.extenders.deferred">
            function <span class="apidocSignatureSpan">knockout.extenders.</span>deferred
            <span class="apidocSignatureSpan">(target, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.extenders.notify">
            function <span class="apidocSignatureSpan">knockout.extenders.</span>notify
            <span class="apidocSignatureSpan">(target, notifyWhen)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.extenders.rateLimit">
            function <span class="apidocSignatureSpan">knockout.extenders.</span>rateLimit
            <span class="apidocSignatureSpan">(target, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.extenders.throttle">
            function <span class="apidocSignatureSpan">knockout.extenders.</span>throttle
            <span class="apidocSignatureSpan">(target, timeout)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.extenders.trackArrayChanges">
            function <span class="apidocSignatureSpan">knockout.extenders.</span>trackArrayChanges
            <span class="apidocSignatureSpan">(target, options)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.knockout.jqueryTmplTemplateEngine">module knockout.jqueryTmplTemplateEngine</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.jqueryTmplTemplateEngine.jqueryTmplTemplateEngine">
            function <span class="apidocSignatureSpan">knockout.</span>jqueryTmplTemplateEngine
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.knockout.jqueryTmplTemplateEngine.prototype">module knockout.jqueryTmplTemplateEngine.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.jqueryTmplTemplateEngine.prototype.constructor">
            function <span class="apidocSignatureSpan">knockout.jqueryTmplTemplateEngine.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.knockout.memoization">module knockout.memoization</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.memoization.memoize">
            function <span class="apidocSignatureSpan">knockout.memoization.</span>memoize
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.memoization.parseMemoText">
            function <span class="apidocSignatureSpan">knockout.memoization.</span>parseMemoText
            <span class="apidocSignatureSpan">(memoText)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.memoization.unmemoize">
            function <span class="apidocSignatureSpan">knockout.memoization.</span>unmemoize
            <span class="apidocSignatureSpan">(memoId, callbackParams)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.memoization.unmemoizeDomNodeAndDescendants">
            function <span class="apidocSignatureSpan">knockout.memoization.</span>unmemoizeDomNodeAndDescendants
            <span class="apidocSignatureSpan">(domNode, extraCallbackParamsArray)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.knockout.nativeTemplateEngine">module knockout.nativeTemplateEngine</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.nativeTemplateEngine.nativeTemplateEngine">
            function <span class="apidocSignatureSpan">knockout.</span>nativeTemplateEngine
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">knockout.nativeTemplateEngine.</span>instance</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.knockout.nativeTemplateEngine.prototype">module knockout.nativeTemplateEngine.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.nativeTemplateEngine.prototype.constructor">
            function <span class="apidocSignatureSpan">knockout.nativeTemplateEngine.prototype.</span>constructor
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.nativeTemplateEngine.prototype.renderTemplateSource">
            function <span class="apidocSignatureSpan">knockout.nativeTemplateEngine.prototype.</span>renderTemplateSource
            <span class="apidocSignatureSpan">(templateSource, bindingContext, options, templateDocument)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.knockout.selectExtensions">module knockout.selectExtensions</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.selectExtensions.readValue">
            function <span class="apidocSignatureSpan">knockout.selectExtensions.</span>readValue
            <span class="apidocSignatureSpan">(element)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.selectExtensions.writeValue">
            function <span class="apidocSignatureSpan">knockout.selectExtensions.</span>writeValue
            <span class="apidocSignatureSpan">(element, value, allowUnset)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.knockout.subscription">module knockout.subscription</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.subscription.subscription">
            function <span class="apidocSignatureSpan">knockout.</span>subscription
            <span class="apidocSignatureSpan">(target, callback, disposeCallback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.knockout.subscription.prototype">module knockout.subscription.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.subscription.prototype.dispose">
            function <span class="apidocSignatureSpan">knockout.subscription.prototype.</span>dispose
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.knockout.tasks">module knockout.tasks</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.tasks.cancel">
            function <span class="apidocSignatureSpan">knockout.tasks.</span>cancel
            <span class="apidocSignatureSpan">(handle)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.tasks.resetForTesting">
            function <span class="apidocSignatureSpan">knockout.tasks.</span>resetForTesting
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.tasks.runEarly">
            function <span class="apidocSignatureSpan">knockout.tasks.</span>runEarly
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.tasks.schedule">
            function <span class="apidocSignatureSpan">knockout.tasks.</span>schedule
            <span class="apidocSignatureSpan">(func)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.tasks.scheduler">
            function <span class="apidocSignatureSpan">knockout.tasks.</span>scheduler
            <span class="apidocSignatureSpan">(callback)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.knockout.templateEngine">module knockout.templateEngine</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.templateEngine.templateEngine">
            function <span class="apidocSignatureSpan">knockout.</span>templateEngine
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.knockout.templateEngine.prototype">module knockout.templateEngine.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.templateEngine.prototype.createJavaScriptEvaluatorBlock">
            function <span class="apidocSignatureSpan">knockout.templateEngine.prototype.</span>createJavaScriptEvaluatorBlock
            <span class="apidocSignatureSpan">(script)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.templateEngine.prototype.isTemplateRewritten">
            function <span class="apidocSignatureSpan">knockout.templateEngine.prototype.</span>isTemplateRewritten
            <span class="apidocSignatureSpan">(template, templateDocument)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.templateEngine.prototype.makeTemplateSource">
            function <span class="apidocSignatureSpan">knockout.templateEngine.prototype.</span>makeTemplateSource
            <span class="apidocSignatureSpan">(template, templateDocument)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.templateEngine.prototype.renderTemplate">
            function <span class="apidocSignatureSpan">knockout.templateEngine.prototype.</span>renderTemplate
            <span class="apidocSignatureSpan">(template, bindingContext, options, templateDocument)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.templateEngine.prototype.renderTemplateSource">
            function <span class="apidocSignatureSpan">knockout.templateEngine.prototype.</span>renderTemplateSource
            <span class="apidocSignatureSpan">(templateSource, bindingContext, options, templateDocument)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.templateEngine.prototype.rewriteTemplate">
            function <span class="apidocSignatureSpan">knockout.templateEngine.prototype.</span>rewriteTemplate
            <span class="apidocSignatureSpan">(template, rewriterCallback, templateDocument)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.knockout.templateRewriting">module knockout.templateRewriting</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.templateRewriting.applyMemoizedBindingsToNextSibling">
            function <span class="apidocSignatureSpan">knockout.templateRewriting.</span>applyMemoizedBindingsToNextSibling
            <span class="apidocSignatureSpan">(bindings, nodeName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.templateRewriting.ensureTemplateIsRewritten">
            function <span class="apidocSignatureSpan">knockout.templateRewriting.</span>ensureTemplateIsRewritten
            <span class="apidocSignatureSpan">(template, templateEngine, templateDocument)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.templateRewriting.memoizeBindingAttributeSyntax">
            function <span class="apidocSignatureSpan">knockout.templateRewriting.</span>memoizeBindingAttributeSyntax
            <span class="apidocSignatureSpan">(htmlString, templateEngine)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.knockout.templateSources">module knockout.templateSources</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.templateSources.anonymousTemplate">
            function <span class="apidocSignatureSpan">knockout.templateSources.</span>anonymousTemplate
            <span class="apidocSignatureSpan">(element)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.templateSources.domElement">
            function <span class="apidocSignatureSpan">knockout.templateSources.</span>domElement
            <span class="apidocSignatureSpan">(element)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.knockout.templateSources.anonymousTemplate">module knockout.templateSources.anonymousTemplate</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.templateSources.anonymousTemplate.anonymousTemplate">
            function <span class="apidocSignatureSpan">knockout.templateSources.</span>anonymousTemplate
            <span class="apidocSignatureSpan">(element)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.knockout.templateSources.anonymousTemplate.prototype">module knockout.templateSources.anonymousTemplate.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.templateSources.anonymousTemplate.prototype.constructor">
            function <span class="apidocSignatureSpan">knockout.templateSources.anonymousTemplate.prototype.</span>constructor
            <span class="apidocSignatureSpan">(element)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.templateSources.anonymousTemplate.prototype.text">
            function <span class="apidocSignatureSpan">knockout.templateSources.anonymousTemplate.prototype.</span>text
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.knockout.templateSources.domElement">module knockout.templateSources.domElement</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.templateSources.domElement.domElement">
            function <span class="apidocSignatureSpan">knockout.templateSources.</span>domElement
            <span class="apidocSignatureSpan">(element)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.knockout.templateSources.domElement.prototype">module knockout.templateSources.domElement.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.templateSources.domElement.prototype.data">
            function <span class="apidocSignatureSpan">knockout.templateSources.domElement.prototype.</span>data
            <span class="apidocSignatureSpan">(key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.templateSources.domElement.prototype.nodes">
            function <span class="apidocSignatureSpan">knockout.templateSources.domElement.prototype.</span>nodes
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.templateSources.domElement.prototype.text">
            function <span class="apidocSignatureSpan">knockout.templateSources.domElement.prototype.</span>text
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.knockout.utils">module knockout.utils</a><ol>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">knockout.utils.</span>canSetPrototype</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">knockout.utils.</span>isIe6</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">boolean <span class="apidocSignatureSpan">knockout.utils.</span>isIe7</span>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.utils.addOrRemoveItem">
            function <span class="apidocSignatureSpan">knockout.utils.</span>addOrRemoveItem
            <span class="apidocSignatureSpan">(array, value, included)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.utils.anyDomNodeIsAttachedToDocument">
            function <span class="apidocSignatureSpan">knockout.utils.</span>anyDomNodeIsAttachedToDocument
            <span class="apidocSignatureSpan">(nodes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.utils.arrayFilter">
            function <span class="apidocSignatureSpan">knockout.utils.</span>arrayFilter
            <span class="apidocSignatureSpan">(array, predicate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.utils.arrayFirst">
            function <span class="apidocSignatureSpan">knockout.utils.</span>arrayFirst
            <span class="apidocSignatureSpan">(array, predicate, predicateOwner)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.utils.arrayForEach">
            function <span class="apidocSignatureSpan">knockout.utils.</span>arrayForEach
            <span class="apidocSignatureSpan">(array, action)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.utils.arrayGetDistinctValues">
            function <span class="apidocSignatureSpan">knockout.utils.</span>arrayGetDistinctValues
            <span class="apidocSignatureSpan">(array)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.utils.arrayIndexOf">
            function <span class="apidocSignatureSpan">knockout.utils.</span>arrayIndexOf
            <span class="apidocSignatureSpan">(array, item)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.utils.arrayMap">
            function <span class="apidocSignatureSpan">knockout.utils.</span>arrayMap
            <span class="apidocSignatureSpan">(array, mapping)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.utils.arrayPushAll">
            function <span class="apidocSignatureSpan">knockout.utils.</span>arrayPushAll
            <span class="apidocSignatureSpan">(array, valuesToPush)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.utils.arrayRemoveItem">
            function <span class="apidocSignatureSpan">knockout.utils.</span>arrayRemoveItem
            <span class="apidocSignatureSpan">(array, itemToRemove)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.utils.catchFunctionErrors">
            function <span class="apidocSignatureSpan">knockout.utils.</span>catchFunctionErrors
            <span class="apidocSignatureSpan">(delegate)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.utils.cloneNodes">
            function <span class="apidocSignatureSpan">knockout.utils.</span>cloneNodes
            <span class="apidocSignatureSpan">(nodesArray, shouldCleanNodes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.utils.compareArrays">
            function <span class="apidocSignatureSpan">knockout.utils.</span>compareArrays
            <span class="apidocSignatureSpan">(oldArray, newArray, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.utils.createSymbolOrString">
            function <span class="apidocSignatureSpan">knockout.utils.</span>createSymbolOrString
            <span class="apidocSignatureSpan">(identifier)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.utils.deferError">
            function <span class="apidocSignatureSpan">knockout.utils.</span>deferError
            <span class="apidocSignatureSpan">(error)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.utils.domNodeIsAttachedToDocument">
            function <span class="apidocSignatureSpan">knockout.utils.</span>domNodeIsAttachedToDocument
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.utils.domNodeIsContainedBy">
            function <span class="apidocSignatureSpan">knockout.utils.</span>domNodeIsContainedBy
            <span class="apidocSignatureSpan">(node, containedByNode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.utils.emptyDomNode">
            function <span class="apidocSignatureSpan">knockout.utils.</span>emptyDomNode
            <span class="apidocSignatureSpan">(domNode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.utils.ensureSelectElementIsRenderedCorrectly">
            function <span class="apidocSignatureSpan">knockout.utils.</span>ensureSelectElementIsRenderedCorrectly
            <span class="apidocSignatureSpan">(selectElement)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.utils.extend">
            function <span class="apidocSignatureSpan">knockout.utils.</span>extend
            <span class="apidocSignatureSpan">(target, source)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.utils.findMovesInArrayComparison">
            function <span class="apidocSignatureSpan">knockout.utils.</span>findMovesInArrayComparison
            <span class="apidocSignatureSpan">(left, right, limitFailedCompares)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.utils.fixUpContinuousNodeArray">
            function <span class="apidocSignatureSpan">knockout.utils.</span>fixUpContinuousNodeArray
            <span class="apidocSignatureSpan">(continuousNodeArray, parentNode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.utils.forceRefresh">
            function <span class="apidocSignatureSpan">knockout.utils.</span>forceRefresh
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.utils.getFormFields">
            function <span class="apidocSignatureSpan">knockout.utils.</span>getFormFields
            <span class="apidocSignatureSpan">(form, fieldName)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.utils.makeArray">
            function <span class="apidocSignatureSpan">knockout.utils.</span>makeArray
            <span class="apidocSignatureSpan">(arrayLikeObject)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.utils.moveCleanedNodesToContainerElement">
            function <span class="apidocSignatureSpan">knockout.utils.</span>moveCleanedNodesToContainerElement
            <span class="apidocSignatureSpan">(nodes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.utils.objectForEach">
            function <span class="apidocSignatureSpan">knockout.utils.</span>objectForEach
            <span class="apidocSignatureSpan">(obj, action)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.utils.objectMap">
            function <span class="apidocSignatureSpan">knockout.utils.</span>objectMap
            <span class="apidocSignatureSpan">(source, mapping)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.utils.parseHtmlFragment">
            function <span class="apidocSignatureSpan">knockout.utils.</span>parseHtmlFragment
            <span class="apidocSignatureSpan">(html, documentContext)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.utils.parseJson">
            function <span class="apidocSignatureSpan">knockout.utils.</span>parseJson
            <span class="apidocSignatureSpan">(jsonString)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.utils.peekObservable">
            function <span class="apidocSignatureSpan">knockout.utils.</span>peekObservable
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.utils.postJson">
            function <span class="apidocSignatureSpan">knockout.utils.</span>postJson
            <span class="apidocSignatureSpan">(urlOrForm, data, options)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.utils.range">
            function <span class="apidocSignatureSpan">knockout.utils.</span>range
            <span class="apidocSignatureSpan">(min, max)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.utils.registerEventHandler">
            function <span class="apidocSignatureSpan">knockout.utils.</span>registerEventHandler
            <span class="apidocSignatureSpan">(element, eventType, handler)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.utils.replaceDomNodes">
            function <span class="apidocSignatureSpan">knockout.utils.</span>replaceDomNodes
            <span class="apidocSignatureSpan">(nodeToReplaceOrNodeArray, newNodesArray)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.utils.setDomNodeChildren">
            function <span class="apidocSignatureSpan">knockout.utils.</span>setDomNodeChildren
            <span class="apidocSignatureSpan">(domNode, childNodes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.utils.setDomNodeChildrenFromArrayMapping">
            function <span class="apidocSignatureSpan">knockout.utils.</span>setDomNodeChildrenFromArrayMapping
            <span class="apidocSignatureSpan">(domNode, array, mapping, options, callbackAfterAddingNodes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.utils.setElementName">
            function <span class="apidocSignatureSpan">knockout.utils.</span>setElementName
            <span class="apidocSignatureSpan">(element, name)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.utils.setHtml">
            function <span class="apidocSignatureSpan">knockout.utils.</span>setHtml
            <span class="apidocSignatureSpan">(node, html)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.utils.setOptionNodeSelectionState">
            function <span class="apidocSignatureSpan">knockout.utils.</span>setOptionNodeSelectionState
            <span class="apidocSignatureSpan">(optionNode, isSelected)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.utils.setPrototypeOf">
            function <span class="apidocSignatureSpan">knockout.utils.</span>setPrototypeOf
            <span class="apidocSignatureSpan">(obj, proto)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.utils.setPrototypeOfOrExtend">
            function <span class="apidocSignatureSpan">knockout.utils.</span>setPrototypeOfOrExtend
            <span class="apidocSignatureSpan">(obj, proto)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.utils.setTextContent">
            function <span class="apidocSignatureSpan">knockout.utils.</span>setTextContent
            <span class="apidocSignatureSpan">(element, textContent)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.utils.setTimeout">
            function <span class="apidocSignatureSpan">knockout.utils.</span>setTimeout
            <span class="apidocSignatureSpan">(handler, timeout)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.utils.stringStartsWith">
            function <span class="apidocSignatureSpan">knockout.utils.</span>stringStartsWith
            <span class="apidocSignatureSpan">(string, startsWith)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.utils.stringTrim">
            function <span class="apidocSignatureSpan">knockout.utils.</span>stringTrim
            <span class="apidocSignatureSpan">(string)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.utils.stringifyJson">
            function <span class="apidocSignatureSpan">knockout.utils.</span>stringifyJson
            <span class="apidocSignatureSpan">(data, replacer, space)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.utils.tagNameLower">
            function <span class="apidocSignatureSpan">knockout.utils.</span>tagNameLower
            <span class="apidocSignatureSpan">(element)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.utils.toggleDomNodeCssClass">
            function <span class="apidocSignatureSpan">knockout.utils.</span>toggleDomNodeCssClass
            <span class="apidocSignatureSpan">(node, classNames, shouldHaveClass)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.utils.triggerEvent">
            function <span class="apidocSignatureSpan">knockout.utils.</span>triggerEvent
            <span class="apidocSignatureSpan">(element, eventType)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.utils.unwrapObservable">
            function <span class="apidocSignatureSpan">knockout.utils.</span>unwrapObservable
            <span class="apidocSignatureSpan">(value)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">knockout.utils.</span>domData</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">knockout.utils.</span>domNodeDisposal</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">knockout.utils.</span>fieldsIncludedWithJsonPost</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.knockout.utils.domData">module knockout.utils.domData</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.utils.domData.clear">
            function <span class="apidocSignatureSpan">knockout.utils.domData.</span>clear
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.utils.domData.get">
            function <span class="apidocSignatureSpan">knockout.utils.domData.</span>get
            <span class="apidocSignatureSpan">(node, key)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.utils.domData.nextKey">
            function <span class="apidocSignatureSpan">knockout.utils.domData.</span>nextKey
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.utils.domData.set">
            function <span class="apidocSignatureSpan">knockout.utils.domData.</span>set
            <span class="apidocSignatureSpan">(node, key, value)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.knockout.utils.domNodeDisposal">module knockout.utils.domNodeDisposal</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.utils.domNodeDisposal.addDisposeCallback">
            function <span class="apidocSignatureSpan">knockout.utils.domNodeDisposal.</span>addDisposeCallback
            <span class="apidocSignatureSpan">(node, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.utils.domNodeDisposal.cleanExternalData">
            function <span class="apidocSignatureSpan">knockout.utils.domNodeDisposal.</span>cleanExternalData
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.utils.domNodeDisposal.cleanNode">
            function <span class="apidocSignatureSpan">knockout.utils.domNodeDisposal.</span>cleanNode
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.utils.domNodeDisposal.removeDisposeCallback">
            function <span class="apidocSignatureSpan">knockout.utils.domNodeDisposal.</span>removeDisposeCallback
            <span class="apidocSignatureSpan">(node, callback)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.utils.domNodeDisposal.removeNode">
            function <span class="apidocSignatureSpan">knockout.utils.domNodeDisposal.</span>removeNode
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.knockout.virtualElements">module knockout.virtualElements</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.virtualElements.childNodes">
            function <span class="apidocSignatureSpan">knockout.virtualElements.</span>childNodes
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.virtualElements.emptyNode">
            function <span class="apidocSignatureSpan">knockout.virtualElements.</span>emptyNode
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.virtualElements.firstChild">
            function <span class="apidocSignatureSpan">knockout.virtualElements.</span>firstChild
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.virtualElements.hasBindingValue">
            function <span class="apidocSignatureSpan">knockout.virtualElements.</span>hasBindingValue
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.virtualElements.insertAfter">
            function <span class="apidocSignatureSpan">knockout.virtualElements.</span>insertAfter
            <span class="apidocSignatureSpan">(containerNode, nodeToInsert, insertAfterNode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.virtualElements.nextSibling">
            function <span class="apidocSignatureSpan">knockout.virtualElements.</span>nextSibling
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.virtualElements.normaliseVirtualElementDomStructure">
            function <span class="apidocSignatureSpan">knockout.virtualElements.</span>normaliseVirtualElementDomStructure
            <span class="apidocSignatureSpan">(elementVerified)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.virtualElements.prepend">
            function <span class="apidocSignatureSpan">knockout.virtualElements.</span>prepend
            <span class="apidocSignatureSpan">(containerNode, nodeToPrepend)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.virtualElements.setDomNodeChildren">
            function <span class="apidocSignatureSpan">knockout.virtualElements.</span>setDomNodeChildren
            <span class="apidocSignatureSpan">(node, childNodes)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.knockout.virtualElements.virtualNodeBindingValue">
            function <span class="apidocSignatureSpan">knockout.virtualElements.</span>virtualNodeBindingValue
            <span class="apidocSignatureSpan">(node)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">knockout.virtualElements.</span>allowedBindings</span>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.knockout" id="apidoc.module.knockout">module knockout</a></h1>


    <h2>
        <a href="#apidoc.element.knockout.__tr_ambtns" id="apidoc.element.knockout.__tr_ambtns">
        function <span class="apidocSignatureSpan">knockout.</span>__tr_ambtns
        <span class="apidocSignatureSpan">(bindings, nodeName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">__tr_ambtns = function (bindings, nodeName) {
    return ko.memoization.memoize(function (domNode, bindingContext) {
        var nodeToBind = domNode.nextSibling;
        if (nodeToBind &amp;&amp; nodeToBind.nodeName.toLowerCase() === nodeName) {
            ko.applyBindingAccessorsToNode(nodeToBind, bindings, bindingContext);
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.applyBindingAccessorsToNode" id="apidoc.element.knockout.applyBindingAccessorsToNode">
        function <span class="apidocSignatureSpan">knockout.</span>applyBindingAccessorsToNode
        <span class="apidocSignatureSpan">(node, bindings, viewModelOrBindingContext)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">applyBindingAccessorsToNode = function (node, bindings, viewModelOrBindingContext) {
    if (node.nodeType === 1) // If it's an element, workaround IE &lt;= 8 HTML parsing weirdness
        ko.virtualElements.normaliseVirtualElementDomStructure(node);
    return applyBindingsToNodeInternal(node, bindings, getBindingContext(viewModelOrBindingContext), true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.applyBindings" id="apidoc.element.knockout.applyBindings">
        function <span class="apidocSignatureSpan">knockout.</span>applyBindings
        <span class="apidocSignatureSpan">(viewModelOrBindingContext, rootNode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">applyBindings = function (viewModelOrBindingContext, rootNode) {
    // If jQuery is loaded after Knockout, we won't initially have access to it. So save it here.
    if (!jQueryInstance &amp;&amp; window['jQuery']) {
        jQueryInstance = window['jQuery'];
    }

    if (rootNode &amp;&amp; (rootNode.nodeType !== 1) &amp;&amp; (rootNode.nodeType !== 8))
        throw new Error("ko.applyBindings: first parameter should be your view model; second parameter should be a DOM node");
    rootNode = rootNode || window.document.body; // Make "rootNode" parameter optional

    applyBindingsToNodeAndDescendantsInternal(getBindingContext(viewModelOrBindingContext), rootNode, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.applyBindingsToDescendants" id="apidoc.element.knockout.applyBindingsToDescendants">
        function <span class="apidocSignatureSpan">knockout.</span>applyBindingsToDescendants
        <span class="apidocSignatureSpan">(viewModelOrBindingContext, rootNode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">applyBindingsToDescendants = function (viewModelOrBindingContext, rootNode) {
    if (rootNode.nodeType === 1 || rootNode.nodeType === 8)
        applyBindingsToDescendantsInternal(getBindingContext(viewModelOrBindingContext), rootNode, true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.applyBindingsToNode" id="apidoc.element.knockout.applyBindingsToNode">
        function <span class="apidocSignatureSpan">knockout.</span>applyBindingsToNode
        <span class="apidocSignatureSpan">(node, bindings, viewModelOrBindingContext)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">applyBindingsToNode = function (node, bindings, viewModelOrBindingContext) {
    var context = getBindingContext(viewModelOrBindingContext);
    return ko.applyBindingAccessorsToNode(node, makeBindingAccessors(bindings, context, node), context);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.bindingContext" id="apidoc.element.knockout.bindingContext">
        function <span class="apidocSignatureSpan">knockout.</span>bindingContext
        <span class="apidocSignatureSpan">(dataItemOrAccessor, parentContext, dataItemAlias, extendCallback, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bindingContext = function (dataItemOrAccessor, parentContext, dataItemAlias, extendCallback, options) {

    // The binding context object includes static properties for the current, parent, and root view models.
    // If a view model is actually stored in an observable, the corresponding binding context object, and
    // any child contexts, must be updated when the view model is changed.
    function updateContext() {
        // Most of the time, the context will directly get a view model object, but if a function is given,
        // we call the function to retrieve the view model. If the function accesses any observables or returns
        // an observable, the dependency is tracked, and those observables can later cause the binding
        // context to be updated.
        var dataItemOrObservable = isFunc ? dataItemOrAccessor() : dataItemOrAccessor,
            dataItem = ko.utils.unwrapObservable(dataItemOrObservable);

        if (parentContext) {
            // When a "parent" context is given, register a dependency on the parent context. Thus whenever the
            // parent context is updated, this context will also be updated.
            if (parentContext._subscribable)
                parentContext._subscribable();

            // Copy $root and any custom properties from the parent context
            ko.utils.extend(self, parentContext);

            // Because the above copy overwrites our own properties, we need to reset them.
            self._subscribable = subscribable;
        } else {
            self['$parents'] = [];
            self['$root'] = dataItem;

            // Export 'ko' in the binding context so it will be available in bindings and templates
            // even if 'ko' isn't exported as a global, such as when using an AMD loader.
            // See https://github.com/SteveSanderson/knockout/issues/490
            self['ko'] = ko;
        }
        self['$rawData'] = dataItemOrObservable;
        self['$data'] = dataItem;
        if (dataItemAlias)
            self[dataItemAlias] = dataItem;

        // The extendCallback function is provided when creating a child context or extending a context.
        // It handles the specific actions needed to finish setting up the binding context. Actions in this
        // function could also add dependencies to this binding context.
        if (extendCallback)
            extendCallback(self, parentContext, dataItem);

        return self['$data'];
    }
    function disposeWhen() {
        return nodes &amp;&amp; !ko.utils.anyDomNodeIsAttachedToDocument(nodes);
    }

    var self = this,
        isFunc = typeof(dataItemOrAccessor) == "function" &amp;&amp; !ko.isObservable(dataItemOrAccessor),
        nodes,
        subscribable;

    if (options &amp;&amp; options['exportDependencies']) {
        // The "exportDependencies" option means that the calling code will track any dependencies and re-create
        // the binding context when they change.
        updateContext();
    } else {
        subscribable = ko.dependentObservable(updateContext, null, { disposeWhen: disposeWhen, disposeWhenNodeIsRemoved: true });

        // At this point, the binding context has been initialized, and the "subscribable" computed observable is
        // subscribed to any observables that were accessed in the process. If there is nothing to track, the
        // computed will be inactive, and we can safely throw it away. If it's active, the computed is stored in
        // the context object.
        if (subscribable.isActive()) {
            self._subscribable = subscribable;

            // Always notify because even if the model ($data) hasn't changed, other context properties might have changed
            subscribable['equalityComparer'] = null;

            // We need to be able to dispose of this computed observable when it's no longer needed. This would be
            // easy if we had a single node to watch, but binding contexts can be used by many different nodes, and
            // we cannot assume that those nodes have any relation to each other. So instead we track any node that ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.bindingProvider" id="apidoc.element.knockout.bindingProvider">
        function <span class="apidocSignatureSpan">knockout.</span>bindingProvider
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bindingProvider = function () {
    this.bindingCache = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.cleanNode" id="apidoc.element.knockout.cleanNode">
        function <span class="apidocSignatureSpan">knockout.</span>cleanNode
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cleanNode = function (node) {
    // First clean this node, where applicable
    if (cleanableNodeTypes[node.nodeType]) {
        cleanSingleNode(node);

        // ... then its descendants, where applicable
        if (cleanableNodeTypesWithDescendants[node.nodeType]) {
            // Clone the descendants list in case it changes during iteration
            var descendants = [];
            ko.utils.arrayPushAll(descendants, node.getElementsByTagName("*"));
            for (var i = 0, j = descendants.length; i &lt; j; i++)
                cleanSingleNode(descendants[i]);
        }
    }
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.computed" id="apidoc.element.knockout.computed">
        function <span class="apidocSignatureSpan">knockout.</span>computed
        <span class="apidocSignatureSpan">(evaluatorFunctionOrOptions, evaluatorFunctionTarget, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">computed = function (evaluatorFunctionOrOptions, evaluatorFunctionTarget, options) {
    if (typeof evaluatorFunctionOrOptions === "object") {
        // Single-parameter syntax - everything is on this "options" param
        options = evaluatorFunctionOrOptions;
    } else {
        // Multi-parameter syntax - construct the options according to the params passed
        options = options || {};
        if (evaluatorFunctionOrOptions) {
            options["read"] = evaluatorFunctionOrOptions;
        }
    }
    if (typeof options["read"] != "function")
        throw Error("Pass a function that returns the value of the ko.computed");

    var writeFunction = options["write"];
    var state = {
        latestValue: undefined,
        isStale: true,
        isDirty: true,
        isBeingEvaluated: false,
        suppressDisposalUntilDisposeWhenReturnsFalse: false,
        isDisposed: false,
        pure: false,
        isSleeping: false,
        readFunction: options["read"],
        evaluatorFunctionTarget: evaluatorFunctionTarget || options["owner"],
        disposeWhenNodeIsRemoved: options["disposeWhenNodeIsRemoved"] || options.disposeWhenNodeIsRemoved || null,
        disposeWhen: options["disposeWhen"] || options.disposeWhen,
        domNodeDisposalCallback: null,
        dependencyTracking: {},
        dependenciesCount: 0,
        evaluationTimeoutInstance: null
    };

    function computedObservable() {
        if (arguments.length &gt; 0) {
            if (typeof writeFunction === "function") {
                // Writing a value
                writeFunction.apply(state.evaluatorFunctionTarget, arguments);
            } else {
                throw new Error("Cannot write a value to a ko.computed unless you specify a 'write' option. If you wish to read
the current value, don't pass any parameters.");
            }
            return this; // Permits chained assignments
        } else {
            // Reading the value
            ko.dependencyDetection.registerDependency(computedObservable);
            if (state.isDirty || (state.isSleeping &amp;&amp; computedObservable.haveDependenciesChanged())) {
                computedObservable.evaluateImmediate();
            }
            return state.latestValue;
        }
    }

    computedObservable[computedState] = state;
    computedObservable.hasWriteFunction = typeof writeFunction === "function";

    // Inherit from 'subscribable'
    if (!ko.utils.canSetPrototype) {
        // 'subscribable' won't be on the prototype chain unless we put it there directly
        ko.utils.extend(computedObservable, ko.subscribable['fn']);
    }
    ko.subscribable['fn'].init(computedObservable);

    // Inherit from 'computed'
    ko.utils.setPrototypeOfOrExtend(computedObservable, computedFn);

    if (options['pure']) {
        state.pure = true;
        state.isSleeping = true;     // Starts off sleeping; will awake on the first subscription
        ko.utils.extend(computedObservable, pureComputedOverrides);
    } else if (options['deferEvaluation']) {
        ko.utils.extend(computedObservable, deferEvaluationOverrides);
    }

    if (ko.options['deferUpdates']) {
        ko.extenders['deferred'](computedObservable, true);
    }

    if (DEBUG) {
        // #1731 - Aid debugging by exposing the computed's options
        computedObservable["_options"] = options;
    }

    if (state.disposeWhenNodeIsRemoved) {
        // Since this computed is associated with a DOM node, and we don't want to dispose the computed
        // until the DOM node is *removed* from the document (as opposed to never having been in the document),
        // we'll prevent disposal until "disposeWhen" first returns false.
        state.suppressDisposalUntilDisposeWhenReturnsFalse = true;

        // disposeWhenNodeIsRemoved: true can be used to opt into the "only dispose after first false result"
        // behaviour even if there's no specific node to watch. In that case, clear the option so we don't try
        // to watch for a non-node's disposal. This technique is intended for KO's internal use only and shouldn't ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.contextFor" id="apidoc.element.knockout.contextFor">
        function <span class="apidocSignatureSpan">knockout.</span>contextFor
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">contextFor = function (node) {
    // We can only do something meaningful for elements and comment nodes (in particular, not text nodes, as IE can't store domdata
 for them)
    switch (node.nodeType) {
        case 1:
        case 8:
            var context = ko.storedBindingContextForNode(node);
            if (context) return context;
            if (node.parentNode) return ko.contextFor(node.parentNode);
            break;
    }
    return undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.dataFor" id="apidoc.element.knockout.dataFor">
        function <span class="apidocSignatureSpan">knockout.</span>dataFor
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dataFor = function (node) {
    var context = ko.contextFor(node);
    return context ? context['$data'] : undefined;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.dependentObservable" id="apidoc.element.knockout.dependentObservable">
        function <span class="apidocSignatureSpan">knockout.</span>dependentObservable
        <span class="apidocSignatureSpan">(evaluatorFunctionOrOptions, evaluatorFunctionTarget, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dependentObservable = function (evaluatorFunctionOrOptions, evaluatorFunctionTarget, options) {
    if (typeof evaluatorFunctionOrOptions === "object") {
        // Single-parameter syntax - everything is on this "options" param
        options = evaluatorFunctionOrOptions;
    } else {
        // Multi-parameter syntax - construct the options according to the params passed
        options = options || {};
        if (evaluatorFunctionOrOptions) {
            options["read"] = evaluatorFunctionOrOptions;
        }
    }
    if (typeof options["read"] != "function")
        throw Error("Pass a function that returns the value of the ko.computed");

    var writeFunction = options["write"];
    var state = {
        latestValue: undefined,
        isStale: true,
        isDirty: true,
        isBeingEvaluated: false,
        suppressDisposalUntilDisposeWhenReturnsFalse: false,
        isDisposed: false,
        pure: false,
        isSleeping: false,
        readFunction: options["read"],
        evaluatorFunctionTarget: evaluatorFunctionTarget || options["owner"],
        disposeWhenNodeIsRemoved: options["disposeWhenNodeIsRemoved"] || options.disposeWhenNodeIsRemoved || null,
        disposeWhen: options["disposeWhen"] || options.disposeWhen,
        domNodeDisposalCallback: null,
        dependencyTracking: {},
        dependenciesCount: 0,
        evaluationTimeoutInstance: null
    };

    function computedObservable() {
        if (arguments.length &gt; 0) {
            if (typeof writeFunction === "function") {
                // Writing a value
                writeFunction.apply(state.evaluatorFunctionTarget, arguments);
            } else {
                throw new Error("Cannot write a value to a ko.computed unless you specify a 'write' option. If you wish to read
the current value, don't pass any parameters.");
            }
            return this; // Permits chained assignments
        } else {
            // Reading the value
            ko.dependencyDetection.registerDependency(computedObservable);
            if (state.isDirty || (state.isSleeping &amp;&amp; computedObservable.haveDependenciesChanged())) {
                computedObservable.evaluateImmediate();
            }
            return state.latestValue;
        }
    }

    computedObservable[computedState] = state;
    computedObservable.hasWriteFunction = typeof writeFunction === "function";

    // Inherit from 'subscribable'
    if (!ko.utils.canSetPrototype) {
        // 'subscribable' won't be on the prototype chain unless we put it there directly
        ko.utils.extend(computedObservable, ko.subscribable['fn']);
    }
    ko.subscribable['fn'].init(computedObservable);

    // Inherit from 'computed'
    ko.utils.setPrototypeOfOrExtend(computedObservable, computedFn);

    if (options['pure']) {
        state.pure = true;
        state.isSleeping = true;     // Starts off sleeping; will awake on the first subscription
        ko.utils.extend(computedObservable, pureComputedOverrides);
    } else if (options['deferEvaluation']) {
        ko.utils.extend(computedObservable, deferEvaluationOverrides);
    }

    if (ko.options['deferUpdates']) {
        ko.extenders['deferred'](computedObservable, true);
    }

    if (DEBUG) {
        // #1731 - Aid debugging by exposing the computed's options
        computedObservable["_options"] = options;
    }

    if (state.disposeWhenNodeIsRemoved) {
        // Since this computed is associated with a DOM node, and we don't want to dispose the computed
        // until the DOM node is *removed* from the document (as opposed to never having been in the document),
        // we'll prevent disposal until "disposeWhen" first returns false.
        state.suppressDisposalUntilDisposeWhenReturnsFalse = true;

        // disposeWhenNodeIsRemoved: true can be used to opt into the "only dispose after first false result"
        // behaviour even if there's no specific node to watch. In that case, clear the option so we don't try
        // to watch for a non-node's disposal. This technique is intended for KO's internal use only and shouldn't ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.exportProperty" id="apidoc.element.knockout.exportProperty">
        function <span class="apidocSignatureSpan">knockout.</span>exportProperty
        <span class="apidocSignatureSpan">(owner, publicName, object)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exportProperty = function (owner, publicName, object) {
    owner[publicName] = object;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.exportSymbol" id="apidoc.element.knockout.exportSymbol">
        function <span class="apidocSignatureSpan">knockout.</span>exportSymbol
        <span class="apidocSignatureSpan">(koPath, object)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">exportSymbol = function (koPath, object) {
    var tokens = koPath.split(".");

    // In the future, "ko" may become distinct from "koExports" (so that non-exported objects are not reachable)
    // At that point, "target" would be set to: (typeof koExports !== "undefined" ? koExports : ko)
    var target = ko;

    for (var i = 0; i &lt; tokens.length - 1; i++)
        target = target[tokens[i]];
    target[tokens[tokens.length - 1]] = object;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.getBindingHandler" id="apidoc.element.knockout.getBindingHandler">
        function <span class="apidocSignatureSpan">knockout.</span>getBindingHandler
        <span class="apidocSignatureSpan">(bindingKey)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getBindingHandler = function (bindingKey) {
    return ko.bindingHandlers[bindingKey];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.hasPrototype" id="apidoc.element.knockout.hasPrototype">
        function <span class="apidocSignatureSpan">knockout.</span>hasPrototype
        <span class="apidocSignatureSpan">(instance, prototype)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">hasPrototype = function (instance, prototype) {
    if ((instance === null) || (instance === undefined) || (instance[protoProperty] === undefined)) return false;
    if (instance[protoProperty] === prototype) return true;
    return ko.hasPrototype(instance[protoProperty], prototype); // Walk the prototype chain
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.ignoreDependencies" id="apidoc.element.knockout.ignoreDependencies">
        function <span class="apidocSignatureSpan">knockout.</span>ignoreDependencies
        <span class="apidocSignatureSpan">(callback, callbackTarget, callbackArgs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ignoreDependencies = function (callback, callbackTarget, callbackArgs) {
    try {
        begin();
        return callback.apply(callbackTarget, callbackArgs || []);
    } finally {
        end();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.isComputed" id="apidoc.element.knockout.isComputed">
        function <span class="apidocSignatureSpan">knockout.</span>isComputed
        <span class="apidocSignatureSpan">(instance)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isComputed = function (instance) {
    return ko.hasPrototype(instance, ko.computed);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.isObservable" id="apidoc.element.knockout.isObservable">
        function <span class="apidocSignatureSpan">knockout.</span>isObservable
        <span class="apidocSignatureSpan">(instance)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isObservable = function (instance) {
    return ko.hasPrototype(instance, ko.observable);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.isPureComputed" id="apidoc.element.knockout.isPureComputed">
        function <span class="apidocSignatureSpan">knockout.</span>isPureComputed
        <span class="apidocSignatureSpan">(instance)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isPureComputed = function (instance) {
    return ko.hasPrototype(instance, ko.computed)
        &amp;&amp; instance[computedState] &amp;&amp; instance[computedState].pure;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.isSubscribable" id="apidoc.element.knockout.isSubscribable">
        function <span class="apidocSignatureSpan">knockout.</span>isSubscribable
        <span class="apidocSignatureSpan">(instance)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isSubscribable = function (instance) {
    return instance != null &amp;&amp; typeof instance.subscribe == "function" &amp;&amp; typeof instance["notifySubscribers"] == "function";
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.isWritableObservable" id="apidoc.element.knockout.isWritableObservable">
        function <span class="apidocSignatureSpan">knockout.</span>isWritableObservable
        <span class="apidocSignatureSpan">(instance)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isWritableObservable = function (instance) {
    // Observable
    if ((typeof instance == 'function') &amp;&amp; instance[protoProperty] === ko.observable)
        return true;
    // Writeable dependent observable
    if ((typeof instance == 'function') &amp;&amp; (instance[protoProperty] === ko.dependentObservable) &amp;&amp; (instance.hasWriteFunction))
        return true;
    // Anything else
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.isWriteableObservable" id="apidoc.element.knockout.isWriteableObservable">
        function <span class="apidocSignatureSpan">knockout.</span>isWriteableObservable
        <span class="apidocSignatureSpan">(instance)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isWriteableObservable = function (instance) {
    // Observable
    if ((typeof instance == 'function') &amp;&amp; instance[protoProperty] === ko.observable)
        return true;
    // Writeable dependent observable
    if ((typeof instance == 'function') &amp;&amp; (instance[protoProperty] === ko.dependentObservable) &amp;&amp; (instance.hasWriteFunction))
        return true;
    // Anything else
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.jqueryTmplTemplateEngine" id="apidoc.element.knockout.jqueryTmplTemplateEngine">
        function <span class="apidocSignatureSpan">knockout.</span>jqueryTmplTemplateEngine
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jqueryTmplTemplateEngine = function () {
    // Detect which version of jquery-tmpl you're using. Unfortunately jquery-tmpl
    // doesn't expose a version number, so we have to infer it.
    // Note that as of Knockout 1.3, we only support jQuery.tmpl 1.0.0pre and later,
    // which KO internally refers to as version "2", so older versions are no longer detected.
    var jQueryTmplVersion = this.jQueryTmplVersion = (function() {
        if (!jQueryInstance || !(jQueryInstance['tmpl']))
            return 0;
        // Since it exposes no official version number, we use our own numbering system. To be updated as jquery-tmpl evolves.
        try {
            if (jQueryInstance['tmpl']['tag']['tmpl']['open'].toString().indexOf('__') &gt;= 0) {
                // Since 1.0.0pre, custom tags should append markup to an array called "__"
                return 2; // Final version of jquery.tmpl
            }
        } catch(ex) { /* Apparently not the version we were looking for */ }

        return 1; // Any older version that we don't support
    })();

    function ensureHasReferencedJQueryTemplates() {
        if (jQueryTmplVersion &lt; 2)
            throw new Error("Your version of jQuery.tmpl is too old. Please upgrade to jQuery.tmpl 1.0.0pre or later.");
    }

    function executeTemplate(compiledTemplate, data, jQueryTemplateOptions) {
        return jQueryInstance['tmpl'](compiledTemplate, data, jQueryTemplateOptions);
    }

    this['renderTemplateSource'] = function(templateSource, bindingContext, options, templateDocument) {
        templateDocument = templateDocument || document;
        options = options || {};
        ensureHasReferencedJQueryTemplates();

        // Ensure we have stored a precompiled version of this template (don't want to reparse on every render)
        var precompiled = templateSource['data']('precompiled');
        if (!precompiled) {
            var templateText = templateSource['text']() || "";
            // Wrap in "with($whatever.koBindingContext) { ... }"
            templateText = "{{ko_with $item.koBindingContext}}" + templateText + "{{/ko_with}}";

            precompiled = jQueryInstance['template'](null, templateText);
            templateSource['data']('precompiled', precompiled);
        }

        var data = [bindingContext['$data']]; // Prewrap the data in an array to stop jquery.tmpl from trying to unwrap any arrays
        var jQueryTemplateOptions = jQueryInstance['extend']({ 'koBindingContext': bindingContext }, options['templateOptions']);

        var resultNodes = executeTemplate(precompiled, data, jQueryTemplateOptions);
        resultNodes['appendTo'](templateDocument.createElement("div")); // Using "appendTo" forces jQuery/jQuery.tmpl to perform
 necessary cleanup work

        jQueryInstance['fragments'] = {}; // Clear jQuery's fragment cache to avoid a memory leak after a large number of template
 renders
        return resultNodes;
    };

    this['createJavaScriptEvaluatorBlock'] = function(script) {
        return "{{ko_code ((function() { return " + script + " })()) }}";
    };

    this['addTemplate'] = function(templateName, templateMarkup) {
        document.write("&lt;script type='text/html' id='" + templateName + "'&gt;" + templateMarkup + "&lt;" + "/script&gt;");
    };

    if (jQueryTmplVersion &gt; 0) {
        jQueryInstance['tmpl']['tag']['ko_code'] = {
            open: "__.push($1 || '');"
        };
        jQueryInstance['tmpl']['tag']['ko_with'] = {
            open: "with($1) {",
            close: "} "
        };
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.nativeTemplateEngine" id="apidoc.element.knockout.nativeTemplateEngine">
        function <span class="apidocSignatureSpan">knockout.</span>nativeTemplateEngine
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nativeTemplateEngine = function () {
    this['allowTemplateRewriting'] = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.observable" id="apidoc.element.knockout.observable">
        function <span class="apidocSignatureSpan">knockout.</span>observable
        <span class="apidocSignatureSpan">(initialValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">observable = function (initialValue) {
    function observable() {
        if (arguments.length &gt; 0) {
            // Write

            // Ignore writes if the value hasn't changed
            if (observable.isDifferent(observable[observableLatestValue], arguments[0])) {
                observable.valueWillMutate();
                observable[observableLatestValue] = arguments[0];
                observable.valueHasMutated();
            }
            return this; // Permits chained assignments
        }
        else {
            // Read
            ko.dependencyDetection.registerDependency(observable); // The caller only needs to be notified of changes if they did
 a "read" operation
            return observable[observableLatestValue];
        }
    }

    observable[observableLatestValue] = initialValue;

    // Inherit from 'subscribable'
    if (!ko.utils.canSetPrototype) {
        // 'subscribable' won't be on the prototype chain unless we put it there directly
        ko.utils.extend(observable, ko.subscribable['fn']);
    }
    ko.subscribable['fn'].init(observable);

    // Inherit from 'observable'
    ko.utils.setPrototypeOfOrExtend(observable, observableFn);

    if (ko.options['deferUpdates']) {
        ko.extenders['deferred'](observable, true);
    }

    return observable;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.observableArray" id="apidoc.element.knockout.observableArray">
        function <span class="apidocSignatureSpan">knockout.</span>observableArray
        <span class="apidocSignatureSpan">(initialValues)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">observableArray = function (initialValues) {
    initialValues = initialValues || [];

    if (typeof initialValues != 'object' || !('length' in initialValues))
        throw new Error("The argument passed when initializing an observable array must be an array, or null, or undefined.");

    var result = ko.observable(initialValues);
    ko.utils.setPrototypeOfOrExtend(result, ko.observableArray['fn']);
    return result.extend({'trackArrayChanges':true});
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.pureComputed" id="apidoc.element.knockout.pureComputed">
        function <span class="apidocSignatureSpan">knockout.</span>pureComputed
        <span class="apidocSignatureSpan">(evaluatorFunctionOrOptions, evaluatorFunctionTarget)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">pureComputed = function (evaluatorFunctionOrOptions, evaluatorFunctionTarget) {
    if (typeof evaluatorFunctionOrOptions === 'function') {
        return ko.computed(evaluatorFunctionOrOptions, evaluatorFunctionTarget, {'pure':true});
    } else {
        evaluatorFunctionOrOptions = ko.utils.extend({}, evaluatorFunctionOrOptions);   // make a copy of the parameter object
        evaluatorFunctionOrOptions['pure'] = true;
        return ko.computed(evaluatorFunctionOrOptions, evaluatorFunctionTarget);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.removeNode" id="apidoc.element.knockout.removeNode">
        function <span class="apidocSignatureSpan">knockout.</span>removeNode
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeNode = function (node) {
    ko.cleanNode(node);
    if (node.parentNode)
        node.parentNode.removeChild(node);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.renderTemplate" id="apidoc.element.knockout.renderTemplate">
        function <span class="apidocSignatureSpan">knockout.</span>renderTemplate
        <span class="apidocSignatureSpan">(template, dataOrBindingContext, options, targetNodeOrNodeArray, renderMode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">renderTemplate = function (template, dataOrBindingContext, options, targetNodeOrNodeArray, renderMode) {
    options = options || {};
    if ((options['templateEngine'] || _templateEngine) == undefined)
        throw new Error("Set a template engine before calling renderTemplate");
    renderMode = renderMode || "replaceChildren";

    if (targetNodeOrNodeArray) {
        var firstTargetNode = getFirstNodeFromPossibleArray(targetNodeOrNodeArray);

        var whenToDispose = function () { return (!firstTargetNode) || !ko.utils.domNodeIsAttachedToDocument(firstTargetNode); }; //
Passive disposal (on next evaluation)
        var activelyDisposeWhenNodeIsRemoved = (firstTargetNode &amp;&amp; renderMode == "replaceNode") ? firstTargetNode.parentNode : firstTargetNode
;

        return ko.dependentObservable( // So the DOM is automatically updated when any dependency changes
            function () {
                // Ensure we've got a proper binding context to work with
                var bindingContext = (dataOrBindingContext &amp;&amp; (dataOrBindingContext instanceof ko.bindingContext))
                    ? dataOrBindingContext
                    : new ko.bindingContext(dataOrBindingContext, null, null, null, { "exportDependencies": true });

                var templateName = resolveTemplateName(template, bindingContext['$data'], bindingContext),
                    renderedNodesArray = executeTemplate(targetNodeOrNodeArray, renderMode, templateName, bindingContext, options
);

                if (renderMode == "replaceNode") {
                    targetNodeOrNodeArray = renderedNodesArray;
                    firstTargetNode = getFirstNodeFromPossibleArray(targetNodeOrNodeArray);
                }
            },
            null,
            { disposeWhen: whenToDispose, disposeWhenNodeIsRemoved: activelyDisposeWhenNodeIsRemoved }
        );
    } else {
        // We don't yet have a DOM node to evaluate, so use a memo and render the template later when there is a DOM node
        return ko.memoization.memoize(function (domNode) {
            ko.renderTemplate(template, dataOrBindingContext, options, domNode, "replaceNode");
        });
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.renderTemplateForEach" id="apidoc.element.knockout.renderTemplateForEach">
        function <span class="apidocSignatureSpan">knockout.</span>renderTemplateForEach
        <span class="apidocSignatureSpan">(template, arrayOrObservableArray, options, targetNode, parentBindingContext)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">renderTemplateForEach = function (template, arrayOrObservableArray, options, targetNode, parentBindingContext) {
    // Since setDomNodeChildrenFromArrayMapping always calls executeTemplateForArrayItem and then
    // activateBindingsCallback for added items, we can store the binding context in the former to use in the latter.
    var arrayItemContext;

    // This will be called by setDomNodeChildrenFromArrayMapping to get the nodes to add to targetNode
    var executeTemplateForArrayItem = function (arrayValue, index) {
        // Support selecting template as a function of the data being rendered
        arrayItemContext = parentBindingContext['createChildContext'](arrayValue, options['as'], function(context) {
            context['$index'] = index;
        });

        var templateName = resolveTemplateName(template, arrayValue, arrayItemContext);
        return executeTemplate(null, "ignoreTargetNode", templateName, arrayItemContext, options);
    }

    // This will be called whenever setDomNodeChildrenFromArrayMapping has added nodes to targetNode
    var activateBindingsCallback = function(arrayValue, addedNodesArray, index) {
        activateBindingsOnContinuousNodeArray(addedNodesArray, arrayItemContext);
        if (options['afterRender'])
            options['afterRender'](addedNodesArray, arrayValue);

        // release the "cache" variable, so that it can be collected by
        // the GC when its value isn't used from within the bindings anymore.
        arrayItemContext = null;
    };

    return ko.dependentObservable(function () {
        var unwrappedArray = ko.utils.unwrapObservable(arrayOrObservableArray) || [];
        if (typeof unwrappedArray.length == "undefined") // Coerce single value into array
            unwrappedArray = [unwrappedArray];

        // Filter out any entries marked as destroyed
        var filteredArray = ko.utils.arrayFilter(unwrappedArray, function(item) {
            return options['includeDestroyed'] || item === undefined || item === null || !ko.utils.unwrapObservable(item['_destroy
']);
        });

        // Call setDomNodeChildrenFromArrayMapping, ignoring any observables unwrapped within (most likely from a callback function
).
        // If the array items are observables, though, they will be unwrapped in executeTemplateForArrayItem and managed within
setDomNodeChildrenFromArrayMapping.
        ko.dependencyDetection.ignore(ko.utils.setDomNodeChildrenFromArrayMapping, null, [targetNode, filteredArray, executeTemplateForArrayItem
, options, activateBindingsCallback]);

    }, null, { disposeWhenNodeIsRemoved: targetNode });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.setTemplateEngine" id="apidoc.element.knockout.setTemplateEngine">
        function <span class="apidocSignatureSpan">knockout.</span>setTemplateEngine
        <span class="apidocSignatureSpan">(templateEngine)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setTemplateEngine = function (templateEngine) {
    if ((templateEngine != undefined) &amp;&amp; !(templateEngine instanceof ko.templateEngine))
        throw new Error("templateEngine must inherit from ko.templateEngine");
    _templateEngine = templateEngine;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.storedBindingContextForNode" id="apidoc.element.knockout.storedBindingContextForNode">
        function <span class="apidocSignatureSpan">knockout.</span>storedBindingContextForNode
        <span class="apidocSignatureSpan">(node, bindingContext)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">storedBindingContextForNode = function (node, bindingContext) {
    if (arguments.length == 2) {
        ko.utils.domData.set(node, storedBindingContextDomDataKey, bindingContext);
        if (bindingContext._subscribable)
            bindingContext._subscribable._addNode(node);
    } else {
        return ko.utils.domData.get(node, storedBindingContextDomDataKey);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.subscribable" id="apidoc.element.knockout.subscribable">
        function <span class="apidocSignatureSpan">knockout.</span>subscribable
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">subscribable = function () {
    ko.utils.setPrototypeOfOrExtend(this, ko_subscribable_fn);
    ko_subscribable_fn.init(this);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.subscription" id="apidoc.element.knockout.subscription">
        function <span class="apidocSignatureSpan">knockout.</span>subscription
        <span class="apidocSignatureSpan">(target, callback, disposeCallback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">subscription = function (target, callback, disposeCallback) {
    this._target = target;
    this.callback = callback;
    this.disposeCallback = disposeCallback;
    this.isDisposed = false;
    ko.exportProperty(this, 'dispose', this.dispose);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.templateEngine" id="apidoc.element.knockout.templateEngine">
        function <span class="apidocSignatureSpan">knockout.</span>templateEngine
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">templateEngine = function () { }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.templateSources.anonymousTemplate" id="apidoc.element.knockout.templateSources.anonymousTemplate">
        function <span class="apidocSignatureSpan">knockout.</span>templateSources.anonymousTemplate
        <span class="apidocSignatureSpan">(element)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">templateSources.anonymousTemplate = function (element) {
    this.domElement = element;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.templateSources.domElement" id="apidoc.element.knockout.templateSources.domElement">
        function <span class="apidocSignatureSpan">knockout.</span>templateSources.domElement
        <span class="apidocSignatureSpan">(element)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">templateSources.domElement = function (element) {
    this.domElement = element;

    if (element) {
        var tagNameLower = ko.utils.tagNameLower(element);
        this.templateType =
            tagNameLower === "script" ? templateScript :
            tagNameLower === "textarea" ? templateTextArea :
                // For browsers with proper &lt;template&gt; element support, where the .content property gives a document fragment
            tagNameLower == "template" &amp;&amp; element.content &amp;&amp; element.content.nodeType === 11 ? templateTemplate :
            templateElement;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.toJS" id="apidoc.element.knockout.toJS">
        function <span class="apidocSignatureSpan">knockout.</span>toJS
        <span class="apidocSignatureSpan">(rootObject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJS = function (rootObject) {
    if (arguments.length == 0)
        throw new Error("When calling ko.toJS, pass the object you want to convert.");

    // We just unwrap everything at every level in the object graph
    return mapJsObjectGraph(rootObject, function(valueToMap) {
        // Loop because an observable's value might in turn be another observable wrapper
        for (var i = 0; ko.isObservable(valueToMap) &amp;&amp; (i &lt; maxNestedObservableDepth); i++)
            valueToMap = valueToMap();
        return valueToMap;
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.toJSON" id="apidoc.element.knockout.toJSON">
        function <span class="apidocSignatureSpan">knockout.</span>toJSON
        <span class="apidocSignatureSpan">(rootObject, replacer, space)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function (rootObject, replacer, space) {     // replacer and space are optional
    var plainJavaScriptObject = ko.toJS(rootObject);
    return ko.utils.stringifyJson(plainJavaScriptObject, replacer, space);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.unwrap" id="apidoc.element.knockout.unwrap">
        function <span class="apidocSignatureSpan">knockout.</span>unwrap
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unwrap = function (value) {
    return ko.isObservable(value) ? value() : value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




























































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.knockout.bindingContext" id="apidoc.module.knockout.bindingContext">module knockout.bindingContext</a></h1>


    <h2>
        <a href="#apidoc.element.knockout.bindingContext.bindingContext" id="apidoc.element.knockout.bindingContext.bindingContext">
        function <span class="apidocSignatureSpan">knockout.</span>bindingContext
        <span class="apidocSignatureSpan">(dataItemOrAccessor, parentContext, dataItemAlias, extendCallback, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bindingContext = function (dataItemOrAccessor, parentContext, dataItemAlias, extendCallback, options) {

    // The binding context object includes static properties for the current, parent, and root view models.
    // If a view model is actually stored in an observable, the corresponding binding context object, and
    // any child contexts, must be updated when the view model is changed.
    function updateContext() {
        // Most of the time, the context will directly get a view model object, but if a function is given,
        // we call the function to retrieve the view model. If the function accesses any observables or returns
        // an observable, the dependency is tracked, and those observables can later cause the binding
        // context to be updated.
        var dataItemOrObservable = isFunc ? dataItemOrAccessor() : dataItemOrAccessor,
            dataItem = ko.utils.unwrapObservable(dataItemOrObservable);

        if (parentContext) {
            // When a "parent" context is given, register a dependency on the parent context. Thus whenever the
            // parent context is updated, this context will also be updated.
            if (parentContext._subscribable)
                parentContext._subscribable();

            // Copy $root and any custom properties from the parent context
            ko.utils.extend(self, parentContext);

            // Because the above copy overwrites our own properties, we need to reset them.
            self._subscribable = subscribable;
        } else {
            self['$parents'] = [];
            self['$root'] = dataItem;

            // Export 'ko' in the binding context so it will be available in bindings and templates
            // even if 'ko' isn't exported as a global, such as when using an AMD loader.
            // See https://github.com/SteveSanderson/knockout/issues/490
            self['ko'] = ko;
        }
        self['$rawData'] = dataItemOrObservable;
        self['$data'] = dataItem;
        if (dataItemAlias)
            self[dataItemAlias] = dataItem;

        // The extendCallback function is provided when creating a child context or extending a context.
        // It handles the specific actions needed to finish setting up the binding context. Actions in this
        // function could also add dependencies to this binding context.
        if (extendCallback)
            extendCallback(self, parentContext, dataItem);

        return self['$data'];
    }
    function disposeWhen() {
        return nodes &amp;&amp; !ko.utils.anyDomNodeIsAttachedToDocument(nodes);
    }

    var self = this,
        isFunc = typeof(dataItemOrAccessor) == "function" &amp;&amp; !ko.isObservable(dataItemOrAccessor),
        nodes,
        subscribable;

    if (options &amp;&amp; options['exportDependencies']) {
        // The "exportDependencies" option means that the calling code will track any dependencies and re-create
        // the binding context when they change.
        updateContext();
    } else {
        subscribable = ko.dependentObservable(updateContext, null, { disposeWhen: disposeWhen, disposeWhenNodeIsRemoved: true });

        // At this point, the binding context has been initialized, and the "subscribable" computed observable is
        // subscribed to any observables that were accessed in the process. If there is nothing to track, the
        // computed will be inactive, and we can safely throw it away. If it's active, the computed is stored in
        // the context object.
        if (subscribable.isActive()) {
            self._subscribable = subscribable;

            // Always notify because even if the model ($data) hasn't changed, other context properties might have changed
            subscribable['equalityComparer'] = null;

            // We need to be able to dispose of this computed observable when it's no longer needed. This would be
            // easy if we had a single node to watch, but binding contexts can be used by many different nodes, and
            // we cannot assume that those nodes have any relation to each other. So instead we track any node that ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.knockout.bindingContext.prototype" id="apidoc.module.knockout.bindingContext.prototype">module knockout.bindingContext.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.knockout.bindingContext.prototype.createChildContext" id="apidoc.element.knockout.bindingContext.prototype.createChildContext">
        function <span class="apidocSignatureSpan">knockout.bindingContext.prototype.</span>createChildContext
        <span class="apidocSignatureSpan">(dataItemOrAccessor, dataItemAlias, extendCallback, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createChildContext = function (dataItemOrAccessor, dataItemAlias, extendCallback, options) {
    return new ko.bindingContext(dataItemOrAccessor, this, dataItemAlias, function(self, parentContext) {
        // Extend the context hierarchy by setting the appropriate pointers
        self['$parentContext'] = parentContext;
        self['$parent'] = parentContext['$data'];
        self['$parents'] = (parentContext['$parents'] || []).slice(0);
        self['$parents'].unshift(self['$parent']);
        if (extendCallback)
            extendCallback(self);
    }, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.bindingContext.prototype.createStaticChildContext" id="apidoc.element.knockout.bindingContext.prototype.createStaticChildContext">
        function <span class="apidocSignatureSpan">knockout.bindingContext.prototype.</span>createStaticChildContext
        <span class="apidocSignatureSpan">(dataItemOrAccessor, dataItemAlias)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createStaticChildContext = function (dataItemOrAccessor, dataItemAlias) {
    return this['createChildContext'](dataItemOrAccessor, dataItemAlias, null, { "exportDependencies": true });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.bindingContext.prototype.extend" id="apidoc.element.knockout.bindingContext.prototype.extend">
        function <span class="apidocSignatureSpan">knockout.bindingContext.prototype.</span>extend
        <span class="apidocSignatureSpan">(properties)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">extend = function (properties) {
    // If the parent context references an observable view model, "_subscribable" will always be the
    // latest view model object. If not, "_subscribable" isn't set, and we can use the static "$data" value.
    return new ko.bindingContext(this._subscribable || this['$data'], this, null, function(self, parentContext) {
        // This "child" context doesn't directly track a parent observable view model,
        // so we need to manually set the $rawData value to match the parent.
        self['$rawData'] = parentContext['$rawData'];
        ko.utils.extend(self, typeof(properties) == "function" ? properties() : properties);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.knockout.bindingProvider" id="apidoc.module.knockout.bindingProvider">module knockout.bindingProvider</a></h1>


    <h2>
        <a href="#apidoc.element.knockout.bindingProvider.bindingProvider" id="apidoc.element.knockout.bindingProvider.bindingProvider">
        function <span class="apidocSignatureSpan">knockout.</span>bindingProvider
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">bindingProvider = function () {
    this.bindingCache = {};
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.knockout.bindingProvider.prototype" id="apidoc.module.knockout.bindingProvider.prototype">module knockout.bindingProvider.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.knockout.bindingProvider.prototype.getBindingAccessors" id="apidoc.element.knockout.bindingProvider.prototype.getBindingAccessors">
        function <span class="apidocSignatureSpan">knockout.bindingProvider.prototype.</span>getBindingAccessors
        <span class="apidocSignatureSpan">(node, bindingContext)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getBindingAccessors = function (node, bindingContext) {
    var bindingsString = this['getBindingsString'](node, bindingContext),
        parsedBindings = bindingsString ? this['parseBindingsString'](bindingsString, bindingContext, node, { 'valueAccessors':
true }) : null;
    return ko.components.addBindingsForCustomElement(parsedBindings, node, bindingContext, /* valueAccessors */ true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.bindingProvider.prototype.getBindings" id="apidoc.element.knockout.bindingProvider.prototype.getBindings">
        function <span class="apidocSignatureSpan">knockout.bindingProvider.prototype.</span>getBindings
        <span class="apidocSignatureSpan">(node, bindingContext)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getBindings = function (node, bindingContext) {
    var bindingsString = this['getBindingsString'](node, bindingContext),
        parsedBindings = bindingsString ? this['parseBindingsString'](bindingsString, bindingContext, node) : null;
    return ko.components.addBindingsForCustomElement(parsedBindings, node, bindingContext, /* valueAccessors */ false);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.bindingProvider.prototype.getBindingsString" id="apidoc.element.knockout.bindingProvider.prototype.getBindingsString">
        function <span class="apidocSignatureSpan">knockout.bindingProvider.prototype.</span>getBindingsString
        <span class="apidocSignatureSpan">(node, bindingContext)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getBindingsString = function (node, bindingContext) {
    switch (node.nodeType) {
        case 1: return node.getAttribute(defaultBindingAttributeName);   // Element
        case 8: return ko.virtualElements.virtualNodeBindingValue(node); // Comment node
        default: return null;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.bindingProvider.prototype.nodeHasBindings" id="apidoc.element.knockout.bindingProvider.prototype.nodeHasBindings">
        function <span class="apidocSignatureSpan">knockout.bindingProvider.prototype.</span>nodeHasBindings
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nodeHasBindings = function (node) {
    switch (node.nodeType) {
        case 1: // Element
            return node.getAttribute(defaultBindingAttributeName) != null
                || ko.components['getComponentNameForNode'](node);
        case 8: // Comment node
            return ko.virtualElements.hasBindingValue(node);
        default: return false;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.bindingProvider.prototype.parseBindingsString" id="apidoc.element.knockout.bindingProvider.prototype.parseBindingsString">
        function <span class="apidocSignatureSpan">knockout.bindingProvider.prototype.</span>parseBindingsString
        <span class="apidocSignatureSpan">(bindingsString, bindingContext, node, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseBindingsString = function (bindingsString, bindingContext, node, options) {
    try {
        var bindingFunction = createBindingsStringEvaluatorViaCache(bindingsString, this.bindingCache, options);
        return bindingFunction(bindingContext, node);
    } catch (ex) {
        ex.message = "Unable to parse bindings.\nBindings value: " + bindingsString + "\nMessage: " + ex.message;
        throw ex;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.knockout.components" id="apidoc.module.knockout.components">module knockout.components</a></h1>


    <h2>
        <a href="#apidoc.element.knockout.components._getFirstResultFromLoaders" id="apidoc.element.knockout.components._getFirstResultFromLoaders">
        function <span class="apidocSignatureSpan">knockout.components.</span>_getFirstResultFromLoaders
        <span class="apidocSignatureSpan">(methodName, argsExceptCallback, callback, candidateLoaders)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getFirstResultFromLoaders(methodName, argsExceptCallback, callback, candidateLoaders) {
    // On the first call in the stack, start with the full set of loaders
    if (!candidateLoaders) {
        candidateLoaders = ko.components['loaders'].slice(0); // Use a copy, because we'll be mutating this array
    }

    // Try the next candidate
    var currentCandidateLoader = candidateLoaders.shift();
    if (currentCandidateLoader) {
        var methodInstance = currentCandidateLoader[methodName];
        if (methodInstance) {
            var wasAborted = false,
                synchronousReturnValue = methodInstance.apply(currentCandidateLoader, argsExceptCallback.concat(function(result) {
                    if (wasAborted) {
                        callback(null);
                    } else if (result !== null) {
                        // This candidate returned a value. Use it.
                        callback(result);
                    } else {
                        // Try the next candidate
                        getFirstResultFromLoaders(methodName, argsExceptCallback, callback, candidateLoaders);
                    }
                }));

            // Currently, loaders may not return anything synchronously. This leaves open the possibility
            // that we'll extend the API to support synchronous return values in the future. It won't be
            // a breaking change, because currently no loader is allowed to return anything except undefined.
            if (synchronousReturnValue !== undefined) {
                wasAborted = true;

                // Method to suppress exceptions will remain undocumented. This is only to keep
                // KO's specs running tidily, since we can observe the loading got aborted without
                // having exceptions cluttering up the console too.
                if (!currentCandidateLoader['suppressLoaderExceptions']) {
                    throw new Error('Component loaders must supply values by invoking the callback, not by returning values synchronously
.');
                }
            }
        } else {
            // This candidate doesn't have the relevant handler. Synchronously move on to the next one.
            getFirstResultFromLoaders(methodName, argsExceptCallback, callback, candidateLoaders);
        }
    } else {
        // No candidates returned a value
        callback(null);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.components.addBindingsForCustomElement" id="apidoc.element.knockout.components.addBindingsForCustomElement">
        function <span class="apidocSignatureSpan">knockout.components.</span>addBindingsForCustomElement
        <span class="apidocSignatureSpan">(allBindings, node, bindingContext, valueAccessors)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addBindingsForCustomElement = function (allBindings, node, bindingContext, valueAccessors) {
    // Determine if it's really a custom element matching a component
    if (node.nodeType === 1) {
        var componentName = ko.components['getComponentNameForNode'](node);
        if (componentName) {
            // It does represent a component, so add a component binding for it
            allBindings = allBindings || {};

            if (allBindings['component']) {
                // Avoid silently overwriting some other 'component' binding that may already be on the element
                throw new Error('Cannot use the "component" binding on a custom element matching a component');
            }

            var componentBindingValue = { 'name': componentName, 'params': getComponentParamsFromCustomElement(node, bindingContext
) };

            allBindings['component'] = valueAccessors
                ? function() { return componentBindingValue; }
                : componentBindingValue;
        }
    }

    return allBindings;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.components.clearCachedDefinition" id="apidoc.element.knockout.components.clearCachedDefinition">
        function <span class="apidocSignatureSpan">knockout.components.</span>clearCachedDefinition
        <span class="apidocSignatureSpan">(componentName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clearCachedDefinition = function (componentName) {
    delete loadedDefinitionsCache[componentName];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.components.get" id="apidoc.element.knockout.components.get">
        function <span class="apidocSignatureSpan">knockout.components.</span>get
        <span class="apidocSignatureSpan">(componentName, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get = function (componentName, callback) {
    var cachedDefinition = getObjectOwnProperty(loadedDefinitionsCache, componentName);
    if (cachedDefinition) {
        // It's already loaded and cached. Reuse the same definition object.
        // Note that for API consistency, even cache hits complete asynchronously by default.
        // You can bypass this by putting synchronous:true on your component config.
        if (cachedDefinition.isSynchronousComponent) {
            ko.dependencyDetection.ignore(function() { // See comment in loaderRegistryBehaviors.js for reasoning
                callback(cachedDefinition.definition);
            });
        } else {
            ko.tasks.schedule(function() { callback(cachedDefinition.definition); });
        }
    } else {
        // Join the loading process that is already underway, or start a new one.
        loadComponentAndNotify(componentName, callback);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.components.getComponentNameForNode" id="apidoc.element.knockout.components.getComponentNameForNode">
        function <span class="apidocSignatureSpan">knockout.components.</span>getComponentNameForNode
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getComponentNameForNode = function (node) {
    var tagNameLower = ko.utils.tagNameLower(node);
    if (ko.components.isRegistered(tagNameLower)) {
        // Try to determine that this node can be considered a *custom* element; see https://github.com/knockout/knockout/issues
/1603
        if (tagNameLower.indexOf('-') != -1 || ('' + node) == "[object HTMLUnknownElement]" || (ko.utils.ieVersion &lt;= 8 &amp;&amp; node.
tagName === tagNameLower)) {
            return tagNameLower;
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.components.isRegistered" id="apidoc.element.knockout.components.isRegistered">
        function <span class="apidocSignatureSpan">knockout.components.</span>isRegistered
        <span class="apidocSignatureSpan">(componentName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isRegistered = function (componentName) {
    return defaultConfigRegistry.hasOwnProperty(componentName);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.components.register" id="apidoc.element.knockout.components.register">
        function <span class="apidocSignatureSpan">knockout.components.</span>register
        <span class="apidocSignatureSpan">(componentName, config)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">register = function (componentName, config) {
    if (!config) {
        throw new Error('Invalid configuration for ' + componentName);
    }

    if (ko.components.isRegistered(componentName)) {
        throw new Error('Component ' + componentName + ' is already registered');
    }

    defaultConfigRegistry[componentName] = config;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.components.unregister" id="apidoc.element.knockout.components.unregister">
        function <span class="apidocSignatureSpan">knockout.components.</span>unregister
        <span class="apidocSignatureSpan">(componentName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unregister = function (componentName) {
    delete defaultConfigRegistry[componentName];
    ko.components.clearCachedDefinition(componentName);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.knockout.components.defaultLoader" id="apidoc.module.knockout.components.defaultLoader">module knockout.components.defaultLoader</a></h1>


    <h2>
        <a href="#apidoc.element.knockout.components.defaultLoader.getConfig" id="apidoc.element.knockout.components.defaultLoader.getConfig">
        function <span class="apidocSignatureSpan">knockout.components.defaultLoader.</span>getConfig
        <span class="apidocSignatureSpan">(componentName, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getConfig = function (componentName, callback) {
    var result = defaultConfigRegistry.hasOwnProperty(componentName)
        ? defaultConfigRegistry[componentName]
        : null;
    callback(result);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.components.defaultLoader.loadComponent" id="apidoc.element.knockout.components.defaultLoader.loadComponent">
        function <span class="apidocSignatureSpan">knockout.components.defaultLoader.</span>loadComponent
        <span class="apidocSignatureSpan">(componentName, config, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">loadComponent = function (componentName, config, callback) {
    var errorCallback = makeErrorCallback(componentName);
    possiblyGetConfigFromAmd(errorCallback, config, function(loadedConfig) {
        resolveConfig(componentName, errorCallback, loadedConfig, callback);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.components.defaultLoader.loadTemplate" id="apidoc.element.knockout.components.defaultLoader.loadTemplate">
        function <span class="apidocSignatureSpan">knockout.components.defaultLoader.</span>loadTemplate
        <span class="apidocSignatureSpan">(componentName, templateConfig, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">loadTemplate = function (componentName, templateConfig, callback) {
    resolveTemplate(makeErrorCallback(componentName), templateConfig, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.components.defaultLoader.loadViewModel" id="apidoc.element.knockout.components.defaultLoader.loadViewModel">
        function <span class="apidocSignatureSpan">knockout.components.defaultLoader.</span>loadViewModel
        <span class="apidocSignatureSpan">(componentName, viewModelConfig, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">loadViewModel = function (componentName, viewModelConfig, callback) {
    resolveViewModel(makeErrorCallback(componentName), viewModelConfig, callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.knockout.dependencyDetection" id="apidoc.module.knockout.dependencyDetection">module knockout.dependencyDetection</a></h1>


    <h2>
        <a href="#apidoc.element.knockout.dependencyDetection.begin" id="apidoc.element.knockout.dependencyDetection.begin">
        function <span class="apidocSignatureSpan">knockout.dependencyDetection.</span>begin
        <span class="apidocSignatureSpan">(options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function begin(options) {
    outerFrames.push(currentFrame);
    currentFrame = options;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.dependencyDetection.end" id="apidoc.element.knockout.dependencyDetection.end">
        function <span class="apidocSignatureSpan">knockout.dependencyDetection.</span>end
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function end() {
    currentFrame = outerFrames.pop();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.dependencyDetection.getDependenciesCount" id="apidoc.element.knockout.dependencyDetection.getDependenciesCount">
        function <span class="apidocSignatureSpan">knockout.dependencyDetection.</span>getDependenciesCount
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getDependenciesCount = function () {
    if (currentFrame)
        return currentFrame.computed.getDependenciesCount();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.dependencyDetection.ignore" id="apidoc.element.knockout.dependencyDetection.ignore">
        function <span class="apidocSignatureSpan">knockout.dependencyDetection.</span>ignore
        <span class="apidocSignatureSpan">(callback, callbackTarget, callbackArgs)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ignore = function (callback, callbackTarget, callbackArgs) {
    try {
        begin();
        return callback.apply(callbackTarget, callbackArgs || []);
    } finally {
        end();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.dependencyDetection.isInitial" id="apidoc.element.knockout.dependencyDetection.isInitial">
        function <span class="apidocSignatureSpan">knockout.dependencyDetection.</span>isInitial
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isInitial = function () {
    if (currentFrame)
        return currentFrame.isInitial;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.dependencyDetection.registerDependency" id="apidoc.element.knockout.dependencyDetection.registerDependency">
        function <span class="apidocSignatureSpan">knockout.dependencyDetection.</span>registerDependency
        <span class="apidocSignatureSpan">(subscribable)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">registerDependency = function (subscribable) {
    if (currentFrame) {
        if (!ko.isSubscribable(subscribable))
            throw new Error("Only subscribable things can act as dependencies");
        currentFrame.callback.call(currentFrame.callbackTarget, subscribable, subscribable._id || (subscribable._id = getId()));
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.knockout.dependentObservable" id="apidoc.module.knockout.dependentObservable">module knockout.dependentObservable</a></h1>


    <h2>
        <a href="#apidoc.element.knockout.dependentObservable.dependentObservable" id="apidoc.element.knockout.dependentObservable.dependentObservable">
        function <span class="apidocSignatureSpan">knockout.</span>dependentObservable
        <span class="apidocSignatureSpan">(evaluatorFunctionOrOptions, evaluatorFunctionTarget, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dependentObservable = function (evaluatorFunctionOrOptions, evaluatorFunctionTarget, options) {
    if (typeof evaluatorFunctionOrOptions === "object") {
        // Single-parameter syntax - everything is on this "options" param
        options = evaluatorFunctionOrOptions;
    } else {
        // Multi-parameter syntax - construct the options according to the params passed
        options = options || {};
        if (evaluatorFunctionOrOptions) {
            options["read"] = evaluatorFunctionOrOptions;
        }
    }
    if (typeof options["read"] != "function")
        throw Error("Pass a function that returns the value of the ko.computed");

    var writeFunction = options["write"];
    var state = {
        latestValue: undefined,
        isStale: true,
        isDirty: true,
        isBeingEvaluated: false,
        suppressDisposalUntilDisposeWhenReturnsFalse: false,
        isDisposed: false,
        pure: false,
        isSleeping: false,
        readFunction: options["read"],
        evaluatorFunctionTarget: evaluatorFunctionTarget || options["owner"],
        disposeWhenNodeIsRemoved: options["disposeWhenNodeIsRemoved"] || options.disposeWhenNodeIsRemoved || null,
        disposeWhen: options["disposeWhen"] || options.disposeWhen,
        domNodeDisposalCallback: null,
        dependencyTracking: {},
        dependenciesCount: 0,
        evaluationTimeoutInstance: null
    };

    function computedObservable() {
        if (arguments.length &gt; 0) {
            if (typeof writeFunction === "function") {
                // Writing a value
                writeFunction.apply(state.evaluatorFunctionTarget, arguments);
            } else {
                throw new Error("Cannot write a value to a ko.computed unless you specify a 'write' option. If you wish to read
the current value, don't pass any parameters.");
            }
            return this; // Permits chained assignments
        } else {
            // Reading the value
            ko.dependencyDetection.registerDependency(computedObservable);
            if (state.isDirty || (state.isSleeping &amp;&amp; computedObservable.haveDependenciesChanged())) {
                computedObservable.evaluateImmediate();
            }
            return state.latestValue;
        }
    }

    computedObservable[computedState] = state;
    computedObservable.hasWriteFunction = typeof writeFunction === "function";

    // Inherit from 'subscribable'
    if (!ko.utils.canSetPrototype) {
        // 'subscribable' won't be on the prototype chain unless we put it there directly
        ko.utils.extend(computedObservable, ko.subscribable['fn']);
    }
    ko.subscribable['fn'].init(computedObservable);

    // Inherit from 'computed'
    ko.utils.setPrototypeOfOrExtend(computedObservable, computedFn);

    if (options['pure']) {
        state.pure = true;
        state.isSleeping = true;     // Starts off sleeping; will awake on the first subscription
        ko.utils.extend(computedObservable, pureComputedOverrides);
    } else if (options['deferEvaluation']) {
        ko.utils.extend(computedObservable, deferEvaluationOverrides);
    }

    if (ko.options['deferUpdates']) {
        ko.extenders['deferred'](computedObservable, true);
    }

    if (DEBUG) {
        // #1731 - Aid debugging by exposing the computed's options
        computedObservable["_options"] = options;
    }

    if (state.disposeWhenNodeIsRemoved) {
        // Since this computed is associated with a DOM node, and we don't want to dispose the computed
        // until the DOM node is *removed* from the document (as opposed to never having been in the document),
        // we'll prevent disposal until "disposeWhen" first returns false.
        state.suppressDisposalUntilDisposeWhenReturnsFalse = true;

        // disposeWhenNodeIsRemoved: true can be used to opt into the "only dispose after first false result"
        // behaviour even if there's no specific node to watch. In that case, clear the option so we don't try
        // to watch for a non-node's disposal. This technique is intended for KO's internal use only and shouldn't ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.dependentObservable.__ko_proto__" id="apidoc.element.knockout.dependentObservable.__ko_proto__">
        function <span class="apidocSignatureSpan">knockout.dependentObservable.</span>__ko_proto__
        <span class="apidocSignatureSpan">(initialValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">__ko_proto__ = function (initialValue) {
    function observable() {
        if (arguments.length &gt; 0) {
            // Write

            // Ignore writes if the value hasn't changed
            if (observable.isDifferent(observable[observableLatestValue], arguments[0])) {
                observable.valueWillMutate();
                observable[observableLatestValue] = arguments[0];
                observable.valueHasMutated();
            }
            return this; // Permits chained assignments
        }
        else {
            // Read
            ko.dependencyDetection.registerDependency(observable); // The caller only needs to be notified of changes if they did
 a "read" operation
            return observable[observableLatestValue];
        }
    }

    observable[observableLatestValue] = initialValue;

    // Inherit from 'subscribable'
    if (!ko.utils.canSetPrototype) {
        // 'subscribable' won't be on the prototype chain unless we put it there directly
        ko.utils.extend(observable, ko.subscribable['fn']);
    }
    ko.subscribable['fn'].init(observable);

    // Inherit from 'observable'
    ko.utils.setPrototypeOfOrExtend(observable, observableFn);

    if (ko.options['deferUpdates']) {
        ko.extenders['deferred'](observable, true);
    }

    return observable;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.knockout.dependentObservable.fn" id="apidoc.module.knockout.dependentObservable.fn">module knockout.dependentObservable.fn</a></h1>


    <h2>
        <a href="#apidoc.element.knockout.dependentObservable.fn.__ko_proto__" id="apidoc.element.knockout.dependentObservable.fn.__ko_proto__">
        function <span class="apidocSignatureSpan">knockout.dependentObservable.fn.</span>__ko_proto__
        <span class="apidocSignatureSpan">(evaluatorFunctionOrOptions, evaluatorFunctionTarget, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">__ko_proto__ = function (evaluatorFunctionOrOptions, evaluatorFunctionTarget, options) {
    if (typeof evaluatorFunctionOrOptions === "object") {
        // Single-parameter syntax - everything is on this "options" param
        options = evaluatorFunctionOrOptions;
    } else {
        // Multi-parameter syntax - construct the options according to the params passed
        options = options || {};
        if (evaluatorFunctionOrOptions) {
            options["read"] = evaluatorFunctionOrOptions;
        }
    }
    if (typeof options["read"] != "function")
        throw Error("Pass a function that returns the value of the ko.computed");

    var writeFunction = options["write"];
    var state = {
        latestValue: undefined,
        isStale: true,
        isDirty: true,
        isBeingEvaluated: false,
        suppressDisposalUntilDisposeWhenReturnsFalse: false,
        isDisposed: false,
        pure: false,
        isSleeping: false,
        readFunction: options["read"],
        evaluatorFunctionTarget: evaluatorFunctionTarget || options["owner"],
        disposeWhenNodeIsRemoved: options["disposeWhenNodeIsRemoved"] || options.disposeWhenNodeIsRemoved || null,
        disposeWhen: options["disposeWhen"] || options.disposeWhen,
        domNodeDisposalCallback: null,
        dependencyTracking: {},
        dependenciesCount: 0,
        evaluationTimeoutInstance: null
    };

    function computedObservable() {
        if (arguments.length &gt; 0) {
            if (typeof writeFunction === "function") {
                // Writing a value
                writeFunction.apply(state.evaluatorFunctionTarget, arguments);
            } else {
                throw new Error("Cannot write a value to a ko.computed unless you specify a 'write' option. If you wish to read
the current value, don't pass any parameters.");
            }
            return this; // Permits chained assignments
        } else {
            // Reading the value
            ko.dependencyDetection.registerDependency(computedObservable);
            if (state.isDirty || (state.isSleeping &amp;&amp; computedObservable.haveDependenciesChanged())) {
                computedObservable.evaluateImmediate();
            }
            return state.latestValue;
        }
    }

    computedObservable[computedState] = state;
    computedObservable.hasWriteFunction = typeof writeFunction === "function";

    // Inherit from 'subscribable'
    if (!ko.utils.canSetPrototype) {
        // 'subscribable' won't be on the prototype chain unless we put it there directly
        ko.utils.extend(computedObservable, ko.subscribable['fn']);
    }
    ko.subscribable['fn'].init(computedObservable);

    // Inherit from 'computed'
    ko.utils.setPrototypeOfOrExtend(computedObservable, computedFn);

    if (options['pure']) {
        state.pure = true;
        state.isSleeping = true;     // Starts off sleeping; will awake on the first subscription
        ko.utils.extend(computedObservable, pureComputedOverrides);
    } else if (options['deferEvaluation']) {
        ko.utils.extend(computedObservable, deferEvaluationOverrides);
    }

    if (ko.options['deferUpdates']) {
        ko.extenders['deferred'](computedObservable, true);
    }

    if (DEBUG) {
        // #1731 - Aid debugging by exposing the computed's options
        computedObservable["_options"] = options;
    }

    if (state.disposeWhenNodeIsRemoved) {
        // Since this computed is associated with a DOM node, and we don't want to dispose the computed
        // until the DOM node is *removed* from the document (as opposed to never having been in the document),
        // we'll prevent disposal until "disposeWhen" first returns false.
        state.suppressDisposalUntilDisposeWhenReturnsFalse = true;

        // disposeWhenNodeIsRemoved: true can be used to opt into the "only dispose after first false result"
        // behaviour even if there's no specific node to watch. In that case, clear the option so we don't try
        // to watch for a non-node's disposal. This technique is intended for KO's internal use only and shouldn't ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.dependentObservable.fn.addDependencyTracking" id="apidoc.element.knockout.dependentObservable.fn.addDependencyTracking">
        function <span class="apidocSignatureSpan">knockout.dependentObservable.fn.</span>addDependencyTracking
        <span class="apidocSignatureSpan">(id, target, trackingObj)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addDependencyTracking = function (id, target, trackingObj) {
    if (this[computedState].pure &amp;&amp; target === this) {
        throw Error("A 'pure' computed must not be called recursively");
    }

    this[computedState].dependencyTracking[id] = trackingObj;
    trackingObj._order = this[computedState].dependenciesCount++;
    trackingObj._version = target.getVersion();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.dependentObservable.fn.dispose" id="apidoc.element.knockout.dependentObservable.fn.dispose">
        function <span class="apidocSignatureSpan">knockout.dependentObservable.fn.</span>dispose
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dispose = function () {
    var state = this[computedState];
    if (!state.isSleeping &amp;&amp; state.dependencyTracking) {
        ko.utils.objectForEach(state.dependencyTracking, function (id, dependency) {
            if (dependency.dispose)
                dependency.dispose();
        });
    }
    if (state.disposeWhenNodeIsRemoved &amp;&amp; state.domNodeDisposalCallback) {
        ko.utils.domNodeDisposal.removeDisposeCallback(state.disposeWhenNodeIsRemoved, state.domNodeDisposalCallback);
    }
    state.dependencyTracking = null;
    state.dependenciesCount = 0;
    state.isDisposed = true;
    state.isStale = false;
    state.isDirty = false;
    state.isSleeping = false;
    state.disposeWhenNodeIsRemoved = null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.dependentObservable.fn.equalityComparer" id="apidoc.element.knockout.dependentObservable.fn.equalityComparer">
        function <span class="apidocSignatureSpan">knockout.dependentObservable.fn.</span>equalityComparer
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function valuesArePrimitiveAndEqual(a, b) {
    var oldValueIsPrimitive = (a === null) || (typeof(a) in primitiveTypes);
    return oldValueIsPrimitive ? (a === b) : false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.dependentObservable.fn.evaluateImmediate" id="apidoc.element.knockout.dependentObservable.fn.evaluateImmediate">
        function <span class="apidocSignatureSpan">knockout.dependentObservable.fn.</span>evaluateImmediate
        <span class="apidocSignatureSpan">(notifyChange)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">evaluateImmediate = function (notifyChange) {
    var computedObservable = this,
        state = computedObservable[computedState],
        disposeWhen = state.disposeWhen,
        changed = false;

    if (state.isBeingEvaluated) {
        // If the evaluation of a ko.computed causes side effects, it's possible that it will trigger its own re-evaluation.
        // This is not desirable (it's hard for a developer to realise a chain of dependencies might cause this, and they almost
        // certainly didn't intend infinite re-evaluations). So, for predictability, we simply prevent ko.computeds from causing
        // their own re-evaluation. Further discussion at https://github.com/SteveSanderson/knockout/pull/387
        return;
    }

    // Do not evaluate (and possibly capture new dependencies) if disposed
    if (state.isDisposed) {
        return;
    }

    if (state.disposeWhenNodeIsRemoved &amp;&amp; !ko.utils.domNodeIsAttachedToDocument(state.disposeWhenNodeIsRemoved) || disposeWhen &amp;&amp;
disposeWhen()) {
        // See comment above about suppressDisposalUntilDisposeWhenReturnsFalse
        if (!state.suppressDisposalUntilDisposeWhenReturnsFalse) {
            computedObservable.dispose();
            return;
        }
    } else {
        // It just did return false, so we can stop suppressing now
        state.suppressDisposalUntilDisposeWhenReturnsFalse = false;
    }

    state.isBeingEvaluated = true;
    try {
        changed = this.evaluateImmediate_CallReadWithDependencyDetection(notifyChange);
    } finally {
        state.isBeingEvaluated = false;
    }

    if (!state.dependenciesCount) {
        computedObservable.dispose();
    }

    return changed;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.dependentObservable.fn.evaluateImmediate_CallReadThenEndDependencyDetection" id="apidoc.element.knockout.dependentObservable.fn.evaluateImmediate_CallReadThenEndDependencyDetection">
        function <span class="apidocSignatureSpan">knockout.dependentObservable.fn.</span>evaluateImmediate_CallReadThenEndDependencyDetection
        <span class="apidocSignatureSpan">(state, dependencyDetectionContext)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">evaluateImmediate_CallReadThenEndDependencyDetection = function (state, dependencyDetectionContext) {
    // This function is really part of the evaluateImmediate_CallReadWithDependencyDetection logic.
    // You'd never call it from anywhere else. Factoring it out means that evaluateImmediate_CallReadWithDependencyDetection
    // can be independent of try/finally blocks, which contributes to saving about 40% off the CPU
    // overhead of computed evaluation (on V8 at least).

    try {
        var readFunction = state.readFunction;
        return state.evaluatorFunctionTarget ? readFunction.call(state.evaluatorFunctionTarget) : readFunction();
    } finally {
        ko.dependencyDetection.end();

        // For each subscription no longer being used, remove it from the active subscriptions list and dispose it
        if (dependencyDetectionContext.disposalCount &amp;&amp; !state.isSleeping) {
            ko.utils.objectForEach(dependencyDetectionContext.disposalCandidates, computedDisposeDependencyCallback);
        }

        state.isStale = state.isDirty = false;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.dependentObservable.fn.evaluateImmediate_CallReadWithDependencyDetection" id="apidoc.element.knockout.dependentObservable.fn.evaluateImmediate_CallReadWithDependencyDetection">
        function <span class="apidocSignatureSpan">knockout.dependentObservable.fn.</span>evaluateImmediate_CallReadWithDependencyDetection
        <span class="apidocSignatureSpan">(notifyChange)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">evaluateImmediate_CallReadWithDependencyDetection = function (notifyChange) {
    // This function is really just part of the evaluateImmediate logic. You would never call it from anywhere else.
    // Factoring it out into a separate function means it can be independent of the try/catch block in evaluateImmediate,
    // which contributes to saving about 40% off the CPU overhead of computed evaluation (on V8 at least).

    var computedObservable = this,
        state = computedObservable[computedState],
        changed = false;

    // Initially, we assume that none of the subscriptions are still being used (i.e., all are candidates for disposal).
    // Then, during evaluation, we cross off any that are in fact still being used.
    var isInitial = state.pure ? undefined : !state.dependenciesCount,   // If we're evaluating when there are no previous dependencies
, it must be the first time
        dependencyDetectionContext = {
            computedObservable: computedObservable,
            disposalCandidates: state.dependencyTracking,
            disposalCount: state.dependenciesCount
        };

    ko.dependencyDetection.begin({
        callbackTarget: dependencyDetectionContext,
        callback: computedBeginDependencyDetectionCallback,
        computed: computedObservable,
        isInitial: isInitial
    });

    state.dependencyTracking = {};
    state.dependenciesCount = 0;

    var newValue = this.evaluateImmediate_CallReadThenEndDependencyDetection(state, dependencyDetectionContext);

    if (computedObservable.isDifferent(state.latestValue, newValue)) {
        if (!state.isSleeping) {
            computedObservable["notifySubscribers"](state.latestValue, "beforeChange");
        }

        state.latestValue = newValue;
        if (DEBUG) computedObservable._latestValue = newValue;

        if (state.isSleeping) {
            computedObservable.updateVersion();
        } else if (notifyChange) {
            computedObservable["notifySubscribers"](state.latestValue);
        }

        changed = true;
    }

    if (isInitial) {
        computedObservable["notifySubscribers"](state.latestValue, "awake");
    }

    return changed;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.dependentObservable.fn.evaluatePossiblyAsync" id="apidoc.element.knockout.dependentObservable.fn.evaluatePossiblyAsync">
        function <span class="apidocSignatureSpan">knockout.dependentObservable.fn.</span>evaluatePossiblyAsync
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">evaluatePossiblyAsync = function () {
    var computedObservable = this,
        throttleEvaluationTimeout = computedObservable['throttleEvaluation'];
    if (throttleEvaluationTimeout &amp;&amp; throttleEvaluationTimeout &gt;= 0) {
        clearTimeout(this[computedState].evaluationTimeoutInstance);
        this[computedState].evaluationTimeoutInstance = ko.utils.setTimeout(function () {
            computedObservable.evaluateImmediate(true /*notifyChange*/);
        }, throttleEvaluationTimeout);
    } else if (computedObservable._evalDelayed) {
        computedObservable._evalDelayed(true /*isChange*/);
    } else {
        computedObservable.evaluateImmediate(true /*notifyChange*/);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.dependentObservable.fn.getDependenciesCount" id="apidoc.element.knockout.dependentObservable.fn.getDependenciesCount">
        function <span class="apidocSignatureSpan">knockout.dependentObservable.fn.</span>getDependenciesCount
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getDependenciesCount = function () {
    return this[computedState].dependenciesCount;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.dependentObservable.fn.haveDependenciesChanged" id="apidoc.element.knockout.dependentObservable.fn.haveDependenciesChanged">
        function <span class="apidocSignatureSpan">knockout.dependentObservable.fn.</span>haveDependenciesChanged
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">haveDependenciesChanged = function () {
    var id, dependency, dependencyTracking = this[computedState].dependencyTracking;
    for (id in dependencyTracking) {
        if (dependencyTracking.hasOwnProperty(id)) {
            dependency = dependencyTracking[id];
            if ((this._evalDelayed &amp;&amp; dependency._target._notificationIsPending) || dependency._target.hasChanged(dependency._version
)) {
                return true;
            }
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.dependentObservable.fn.isActive" id="apidoc.element.knockout.dependentObservable.fn.isActive">
        function <span class="apidocSignatureSpan">knockout.dependentObservable.fn.</span>isActive
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isActive = function () {
    var state = this[computedState];
    return state.isDirty || state.dependenciesCount &gt; 0;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.dependentObservable.fn.limit" id="apidoc.element.knockout.dependentObservable.fn.limit">
        function <span class="apidocSignatureSpan">knockout.dependentObservable.fn.</span>limit
        <span class="apidocSignatureSpan">(limitFunction)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">limit = function (limitFunction) {
    // Override the limit function with one that delays evaluation as well
    ko.subscribable['fn'].limit.call(this, limitFunction);
    this._evalIfChanged = function () {
        if (this[computedState].isStale) {
            this.evaluateImmediate();
        } else {
            this[computedState].isDirty = false;
        }
        return this[computedState].latestValue;
    };
    this._evalDelayed = function (isChange) {
        this._limitBeforeChange(this[computedState].latestValue);

        // Mark as dirty
        this[computedState].isDirty = true;
        if (isChange) {
            this[computedState].isStale = true;
        }

        // Pass the observable to the "limit" code, which will evaluate it when
        // it's time to do the notification.
        this._limitChange(this);
    };
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.dependentObservable.fn.markDirty" id="apidoc.element.knockout.dependentObservable.fn.markDirty">
        function <span class="apidocSignatureSpan">knockout.dependentObservable.fn.</span>markDirty
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">markDirty = function () {
    // Process "dirty" events if we can handle delayed notifications
    if (this._evalDelayed &amp;&amp; !this[computedState].isBeingEvaluated) {
        this._evalDelayed(false /*isChange*/);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.dependentObservable.fn.peek" id="apidoc.element.knockout.dependentObservable.fn.peek">
        function <span class="apidocSignatureSpan">knockout.dependentObservable.fn.</span>peek
        <span class="apidocSignatureSpan">(evaluate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">peek = function (evaluate) {
    // By default, peek won't re-evaluate, except while the computed is sleeping or to get the initial value when "deferEvaluation
" is set.
    // Pass in true to evaluate if needed.
    var state = this[computedState];
    if ((state.isDirty &amp;&amp; (evaluate || !state.dependenciesCount)) || (state.isSleeping &amp;&amp; this.haveDependenciesChanged())) {
        this.evaluateImmediate();
    }
    return state.latestValue;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.dependentObservable.fn.respondToChange" id="apidoc.element.knockout.dependentObservable.fn.respondToChange">
        function <span class="apidocSignatureSpan">knockout.dependentObservable.fn.</span>respondToChange
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">respondToChange = function () {
    // Ignore "change" events if we've already scheduled a delayed notification
    if (!this._notificationIsPending) {
        this.evaluatePossiblyAsync();
    } else if (this[computedState].isDirty) {
        this[computedState].isStale = true;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.dependentObservable.fn.subscribeToDependency" id="apidoc.element.knockout.dependentObservable.fn.subscribeToDependency">
        function <span class="apidocSignatureSpan">knockout.dependentObservable.fn.</span>subscribeToDependency
        <span class="apidocSignatureSpan">(target)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">subscribeToDependency = function (target) {
    if (target._deferUpdates &amp;&amp; !this[computedState].disposeWhenNodeIsRemoved) {
        var dirtySub = target.subscribe(this.markDirty, this, 'dirty'),
            changeSub = target.subscribe(this.respondToChange, this);
        return {
            _target: target,
            dispose: function () {
                dirtySub.dispose();
                changeSub.dispose();
            }
        };
    } else {
        return target.subscribe(this.evaluatePossiblyAsync, this);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.knockout.expressionRewriting" id="apidoc.module.knockout.expressionRewriting">module knockout.expressionRewriting</a></h1>


    <h2>
        <a href="#apidoc.element.knockout.expressionRewriting.insertPropertyAccessorsIntoJson" id="apidoc.element.knockout.expressionRewriting.insertPropertyAccessorsIntoJson">
        function <span class="apidocSignatureSpan">knockout.expressionRewriting.</span>insertPropertyAccessorsIntoJson
        <span class="apidocSignatureSpan">(bindingsStringOrKeyValueArray, bindingOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function preProcessBindings(bindingsStringOrKeyValueArray, bindingOptions) {
    bindingOptions = bindingOptions || {};

    function processKeyValue(key, val) {
        var writableVal;
        function callPreprocessHook(obj) {
            return (obj &amp;&amp; obj['preprocess']) ? (val = obj['preprocess'](val, key, processKeyValue)) : true;
        }
        if (!bindingParams) {
            if (!callPreprocessHook(ko['getBindingHandler'](key)))
                return;

            if (twoWayBindings[key] &amp;&amp; (writableVal = getWriteableValue(val))) {
                // For two-way bindings, provide a write method in case the value
                // isn't a writable observable.
                propertyAccessorResultStrings.push("'" + key + "':function(_z){" + writableVal + "=_z}");
            }
        }
        // Values are wrapped in a function so that each value can be accessed independently
        if (makeValueAccessors) {
            val = 'function(){return ' + val + ' }';
        }
        resultStrings.push("'" + key + "':" + val);
    }

    var resultStrings = [],
        propertyAccessorResultStrings = [],
        makeValueAccessors = bindingOptions['valueAccessors'],
        bindingParams = bindingOptions['bindingParams'],
        keyValueArray = typeof bindingsStringOrKeyValueArray === "string" ?
            parseObjectLiteral(bindingsStringOrKeyValueArray) : bindingsStringOrKeyValueArray;

    ko.utils.arrayForEach(keyValueArray, function(keyValue) {
        processKeyValue(keyValue.key || keyValue['unknown'], keyValue.value);
    });

    if (propertyAccessorResultStrings.length)
        processKeyValue('_ko_property_writers', "{" + propertyAccessorResultStrings.join(",") + " }");

    return resultStrings.join(",");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.expressionRewriting.keyValueArrayContainsKey" id="apidoc.element.knockout.expressionRewriting.keyValueArrayContainsKey">
        function <span class="apidocSignatureSpan">knockout.expressionRewriting.</span>keyValueArrayContainsKey
        <span class="apidocSignatureSpan">(keyValueArray, key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">keyValueArrayContainsKey = function (keyValueArray, key) {
    for (var i = 0; i &lt; keyValueArray.length; i++)
        if (keyValueArray[i]['key'] == key)
            return true;
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.expressionRewriting.parseObjectLiteral" id="apidoc.element.knockout.expressionRewriting.parseObjectLiteral">
        function <span class="apidocSignatureSpan">knockout.expressionRewriting.</span>parseObjectLiteral
        <span class="apidocSignatureSpan">(objectLiteralString)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function parseObjectLiteral(objectLiteralString) {
    // Trim leading and trailing spaces from the string
    var str = ko.utils.stringTrim(objectLiteralString);

    // Trim braces '{' surrounding the whole object literal
    if (str.charCodeAt(0) === 123) str = str.slice(1, -1);

    // Split into tokens
    var result = [], toks = str.match(bindingToken), key, values = [], depth = 0;

    if (toks) {
        // Append a comma so that we don't need a separate code block to deal with the last item
        toks.push(',');

        for (var i = 0, tok; tok = toks[i]; ++i) {
            var c = tok.charCodeAt(0);
            // A comma signals the end of a key/value pair if depth is zero
            if (c === 44) { // ","
                if (depth &lt;= 0) {
                    result.push((key &amp;&amp; values.length) ? {key: key, value: values.join('')} : {'unknown': key || values.join('')});
                    key = depth = 0;
                    values = [];
                    continue;
                }
            // Simply skip the colon that separates the name and value
            } else if (c === 58) { // ":"
                if (!depth &amp;&amp; !key &amp;&amp; values.length === 1) {
                    key = values.pop();
                    continue;
                }
            // A set of slashes is initially matched as a regular expression, but could be division
            } else if (c === 47 &amp;&amp; i &amp;&amp; tok.length &gt; 1) {  // "/"
                // Look at the end of the previous token to determine if the slash is actually division
                var match = toks[i-1].match(divisionLookBehind);
                if (match &amp;&amp; !keywordRegexLookBehind[match[0]]) {
                    // The slash is actually a division punctuator; re-parse the remainder of the string (not including the slash
)
                    str = str.substr(str.indexOf(tok) + 1);
                    toks = str.match(bindingToken);
                    toks.push(',');
                    i = -1;
                    // Continue with just the slash
                    tok = '/';
                }
            // Increment depth for parentheses, braces, and brackets so that interior commas are ignored
            } else if (c === 40 || c === 123 || c === 91) { // '(', '{', '['
                ++depth;
            } else if (c === 41 || c === 125 || c === 93) { // ')', '}', ']'
                --depth;
            // The key will be the first token; if it's a string, trim the quotes
            } else if (!key &amp;&amp; !values.length &amp;&amp; (c === 34 || c === 39)) { // '"', "'"
                tok = tok.slice(1, -1);
            }
            values.push(tok);
        }
    }
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.expressionRewriting.preProcessBindings" id="apidoc.element.knockout.expressionRewriting.preProcessBindings">
        function <span class="apidocSignatureSpan">knockout.expressionRewriting.</span>preProcessBindings
        <span class="apidocSignatureSpan">(bindingsStringOrKeyValueArray, bindingOptions)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function preProcessBindings(bindingsStringOrKeyValueArray, bindingOptions) {
    bindingOptions = bindingOptions || {};

    function processKeyValue(key, val) {
        var writableVal;
        function callPreprocessHook(obj) {
            return (obj &amp;&amp; obj['preprocess']) ? (val = obj['preprocess'](val, key, processKeyValue)) : true;
        }
        if (!bindingParams) {
            if (!callPreprocessHook(ko['getBindingHandler'](key)))
                return;

            if (twoWayBindings[key] &amp;&amp; (writableVal = getWriteableValue(val))) {
                // For two-way bindings, provide a write method in case the value
                // isn't a writable observable.
                propertyAccessorResultStrings.push("'" + key + "':function(_z){" + writableVal + "=_z}");
            }
        }
        // Values are wrapped in a function so that each value can be accessed independently
        if (makeValueAccessors) {
            val = 'function(){return ' + val + ' }';
        }
        resultStrings.push("'" + key + "':" + val);
    }

    var resultStrings = [],
        propertyAccessorResultStrings = [],
        makeValueAccessors = bindingOptions['valueAccessors'],
        bindingParams = bindingOptions['bindingParams'],
        keyValueArray = typeof bindingsStringOrKeyValueArray === "string" ?
            parseObjectLiteral(bindingsStringOrKeyValueArray) : bindingsStringOrKeyValueArray;

    ko.utils.arrayForEach(keyValueArray, function(keyValue) {
        processKeyValue(keyValue.key || keyValue['unknown'], keyValue.value);
    });

    if (propertyAccessorResultStrings.length)
        processKeyValue('_ko_property_writers', "{" + propertyAccessorResultStrings.join(",") + " }");

    return resultStrings.join(",");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.expressionRewriting.writeValueToProperty" id="apidoc.element.knockout.expressionRewriting.writeValueToProperty">
        function <span class="apidocSignatureSpan">knockout.expressionRewriting.</span>writeValueToProperty
        <span class="apidocSignatureSpan">(property, allBindings, key, value, checkIfDifferent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeValueToProperty = function (property, allBindings, key, value, checkIfDifferent) {
    if (!property || !ko.isObservable(property)) {
        var propWriters = allBindings.get('_ko_property_writers');
        if (propWriters &amp;&amp; propWriters[key])
            propWriters[key](value);
    } else if (ko.isWriteableObservable(property) &amp;&amp; (!checkIfDifferent || property.peek() !== value)) {
        property(value);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.knockout.expressionRewriting.bindingRewriteValidators" id="apidoc.module.knockout.expressionRewriting.bindingRewriteValidators">module knockout.expressionRewriting.bindingRewriteValidators</a></h1>










    <h2>
        <a href="#apidoc.element.knockout.expressionRewriting.bindingRewriteValidators.template" id="apidoc.element.knockout.expressionRewriting.bindingRewriteValidators.template">
        function <span class="apidocSignatureSpan">knockout.expressionRewriting.bindingRewriteValidators.</span>template
        <span class="apidocSignatureSpan">(bindingValue)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">template = function (bindingValue) {
    var parsedBindingValue = ko.expressionRewriting.parseObjectLiteral(bindingValue);

    if ((parsedBindingValue.length == 1) &amp;&amp; parsedBindingValue[0]['unknown'])
        return null; // It looks like a string literal, not an object literal, so treat it as a named template (which is allowed
 for rewriting)

    if (ko.expressionRewriting.keyValueArrayContainsKey(parsedBindingValue, "name"))
        return null; // Named templates can be rewritten, so return "no error"
    return "This template engine does not support anonymous templates nested within its templates";
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.knockout.extenders" id="apidoc.module.knockout.extenders">module knockout.extenders</a></h1>


    <h2>
        <a href="#apidoc.element.knockout.extenders.deferred" id="apidoc.element.knockout.extenders.deferred">
        function <span class="apidocSignatureSpan">knockout.extenders.</span>deferred
        <span class="apidocSignatureSpan">(target, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deferred = function (target, options) {
    if (options !== true) {
        throw new Error('The \'deferred\' extender only accepts the value \'true\', because it is not supported to turn deferral
 off once enabled.')
    }

    if (!target._deferUpdates) {
        target._deferUpdates = true;
        target.limit(function (callback) {
            var handle,
                ignoreUpdates = false;
            return function () {
                if (!ignoreUpdates) {
                    ko.tasks.cancel(handle);
                    handle = ko.tasks.schedule(callback);

                    try {
                        ignoreUpdates = true;
                        target['notifySubscribers'](undefined, 'dirty');
                    } finally {
                        ignoreUpdates = false;
                    }
                }
            };
        });
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.extenders.notify" id="apidoc.element.knockout.extenders.notify">
        function <span class="apidocSignatureSpan">knockout.extenders.</span>notify
        <span class="apidocSignatureSpan">(target, notifyWhen)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">notify = function (target, notifyWhen) {
    target["equalityComparer"] = notifyWhen == "always" ?
        null :  // null equalityComparer means to always notify
        valuesArePrimitiveAndEqual;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.extenders.rateLimit" id="apidoc.element.knockout.extenders.rateLimit">
        function <span class="apidocSignatureSpan">knockout.extenders.</span>rateLimit
        <span class="apidocSignatureSpan">(target, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rateLimit = function (target, options) {
    var timeout, method, limitFunction;

    if (typeof options == 'number') {
        timeout = options;
    } else {
        timeout = options['timeout'];
        method = options['method'];
    }

    // rateLimit supersedes deferred updates
    target._deferUpdates = false;

    limitFunction = method == 'notifyWhenChangesStop' ?  debounce : throttle;
    target.limit(function(callback) {
        return limitFunction(callback, timeout);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.extenders.throttle" id="apidoc.element.knockout.extenders.throttle">
        function <span class="apidocSignatureSpan">knockout.extenders.</span>throttle
        <span class="apidocSignatureSpan">(target, timeout)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">throttle = function (target, timeout) {
    // Throttling means two things:

    // (1) For dependent observables, we throttle *evaluations* so that, no matter how fast its dependencies
    //     notify updates, the target doesn't re-evaluate (and hence doesn't notify) faster than a certain rate
    target['throttleEvaluation'] = timeout;

    // (2) For writable targets (observables, or writable dependent observables), we throttle *writes*
    //     so the target cannot change value synchronously or faster than a certain rate
    var writeTimeoutInstance = null;
    return ko.dependentObservable({
        'read': target,
        'write': function(value) {
            clearTimeout(writeTimeoutInstance);
            writeTimeoutInstance = ko.utils.setTimeout(function() {
                target(value);
            }, timeout);
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.extenders.trackArrayChanges" id="apidoc.element.knockout.extenders.trackArrayChanges">
        function <span class="apidocSignatureSpan">knockout.extenders.</span>trackArrayChanges
        <span class="apidocSignatureSpan">(target, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">trackArrayChanges = function (target, options) {
    // Use the provided options--each call to trackArrayChanges overwrites the previously set options
    target.compareArrayOptions = {};
    if (options &amp;&amp; typeof options == "object") {
        ko.utils.extend(target.compareArrayOptions, options);
    }
    target.compareArrayOptions['sparse'] = true;

    // Only modify the target observable once
    if (target.cacheDiffForKnownOperation) {
        return;
    }
    var trackingChanges = false,
        cachedDiff = null,
        arrayChangeSubscription,
        pendingNotifications = 0,
        underlyingNotifySubscribersFunction,
        underlyingBeforeSubscriptionAddFunction = target.beforeSubscriptionAdd,
        underlyingAfterSubscriptionRemoveFunction = target.afterSubscriptionRemove;

    // Watch "subscribe" calls, and for array change events, ensure change tracking is enabled
    target.beforeSubscriptionAdd = function (event) {
        if (underlyingBeforeSubscriptionAddFunction)
            underlyingBeforeSubscriptionAddFunction.call(target, event);
        if (event === arrayChangeEventName) {
            trackChanges();
        }
    };
    // Watch "dispose" calls, and for array change events, ensure change tracking is disabled when all are disposed
    target.afterSubscriptionRemove = function (event) {
        if (underlyingAfterSubscriptionRemoveFunction)
            underlyingAfterSubscriptionRemoveFunction.call(target, event);
        if (event === arrayChangeEventName &amp;&amp; !target.hasSubscriptionsForEvent(arrayChangeEventName)) {
            if (underlyingNotifySubscribersFunction) {
                target['notifySubscribers'] = underlyingNotifySubscribersFunction;
                underlyingNotifySubscribersFunction = undefined;
            }
            arrayChangeSubscription.dispose();
            trackingChanges = false;
        }
    };

    function trackChanges() {
        // Calling 'trackChanges' multiple times is the same as calling it once
        if (trackingChanges) {
            return;
        }

        trackingChanges = true;

        // Intercept "notifySubscribers" to track how many times it was called.
        underlyingNotifySubscribersFunction = target['notifySubscribers'];
        target['notifySubscribers'] = function(valueToNotify, event) {
            if (!event || event === defaultEvent) {
                ++pendingNotifications;
            }
            return underlyingNotifySubscribersFunction.apply(this, arguments);
        };

        // Each time the array changes value, capture a clone so that on the next
        // change it's possible to produce a diff
        var previousContents = [].concat(target.peek() || []);
        cachedDiff = null;
        arrayChangeSubscription = target.subscribe(function(currentContents) {
            // Make a copy of the current contents and ensure it's an array
            currentContents = [].concat(currentContents || []);

            // Compute the diff and issue notifications, but only if someone is listening
            if (target.hasSubscriptionsForEvent(arrayChangeEventName)) {
                var changes = getChanges(previousContents, currentContents);
            }

            // Eliminate references to the old, removed items, so they can be GCed
            previousContents = currentContents;
            cachedDiff = null;
            pendingNotifications = 0;

            if (changes &amp;&amp; changes.length) {
                target['notifySubscribers'](changes, arrayChangeEventName);
            }
        });
    }

    function getChanges(previousContents, currentContents) {
        // We try to re-use cached diffs.
        // The scenarios where pendingNotifications &gt; 1 are when using rate-limiting or the Deferred Updates
        // plugin, which without this check would not be compatible with arrayChange notifications. Normally,
        // notifications are issued immediately so we wouldn't be queueing up more than one.
        if (!cachedDiff || pendingNotifications &gt; 1) {
            cachedDiff = ko.utils.compareArrays(previousContents, curr ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.knockout.jqueryTmplTemplateEngine" id="apidoc.module.knockout.jqueryTmplTemplateEngine">module knockout.jqueryTmplTemplateEngine</a></h1>


    <h2>
        <a href="#apidoc.element.knockout.jqueryTmplTemplateEngine.jqueryTmplTemplateEngine" id="apidoc.element.knockout.jqueryTmplTemplateEngine.jqueryTmplTemplateEngine">
        function <span class="apidocSignatureSpan">knockout.</span>jqueryTmplTemplateEngine
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">jqueryTmplTemplateEngine = function () {
    // Detect which version of jquery-tmpl you're using. Unfortunately jquery-tmpl
    // doesn't expose a version number, so we have to infer it.
    // Note that as of Knockout 1.3, we only support jQuery.tmpl 1.0.0pre and later,
    // which KO internally refers to as version "2", so older versions are no longer detected.
    var jQueryTmplVersion = this.jQueryTmplVersion = (function() {
        if (!jQueryInstance || !(jQueryInstance['tmpl']))
            return 0;
        // Since it exposes no official version number, we use our own numbering system. To be updated as jquery-tmpl evolves.
        try {
            if (jQueryInstance['tmpl']['tag']['tmpl']['open'].toString().indexOf('__') &gt;= 0) {
                // Since 1.0.0pre, custom tags should append markup to an array called "__"
                return 2; // Final version of jquery.tmpl
            }
        } catch(ex) { /* Apparently not the version we were looking for */ }

        return 1; // Any older version that we don't support
    })();

    function ensureHasReferencedJQueryTemplates() {
        if (jQueryTmplVersion &lt; 2)
            throw new Error("Your version of jQuery.tmpl is too old. Please upgrade to jQuery.tmpl 1.0.0pre or later.");
    }

    function executeTemplate(compiledTemplate, data, jQueryTemplateOptions) {
        return jQueryInstance['tmpl'](compiledTemplate, data, jQueryTemplateOptions);
    }

    this['renderTemplateSource'] = function(templateSource, bindingContext, options, templateDocument) {
        templateDocument = templateDocument || document;
        options = options || {};
        ensureHasReferencedJQueryTemplates();

        // Ensure we have stored a precompiled version of this template (don't want to reparse on every render)
        var precompiled = templateSource['data']('precompiled');
        if (!precompiled) {
            var templateText = templateSource['text']() || "";
            // Wrap in "with($whatever.koBindingContext) { ... }"
            templateText = "{{ko_with $item.koBindingContext}}" + templateText + "{{/ko_with}}";

            precompiled = jQueryInstance['template'](null, templateText);
            templateSource['data']('precompiled', precompiled);
        }

        var data = [bindingContext['$data']]; // Prewrap the data in an array to stop jquery.tmpl from trying to unwrap any arrays
        var jQueryTemplateOptions = jQueryInstance['extend']({ 'koBindingContext': bindingContext }, options['templateOptions']);

        var resultNodes = executeTemplate(precompiled, data, jQueryTemplateOptions);
        resultNodes['appendTo'](templateDocument.createElement("div")); // Using "appendTo" forces jQuery/jQuery.tmpl to perform
 necessary cleanup work

        jQueryInstance['fragments'] = {}; // Clear jQuery's fragment cache to avoid a memory leak after a large number of template
 renders
        return resultNodes;
    };

    this['createJavaScriptEvaluatorBlock'] = function(script) {
        return "{{ko_code ((function() { return " + script + " })()) }}";
    };

    this['addTemplate'] = function(templateName, templateMarkup) {
        document.write("&lt;script type='text/html' id='" + templateName + "'&gt;" + templateMarkup + "&lt;" + "/script&gt;");
    };

    if (jQueryTmplVersion &gt; 0) {
        jQueryInstance['tmpl']['tag']['ko_code'] = {
            open: "__.push($1 || '');"
        };
        jQueryInstance['tmpl']['tag']['ko_with'] = {
            open: "with($1) {",
            close: "} "
        };
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.knockout.jqueryTmplTemplateEngine.prototype" id="apidoc.module.knockout.jqueryTmplTemplateEngine.prototype">module knockout.jqueryTmplTemplateEngine.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.knockout.jqueryTmplTemplateEngine.prototype.constructor" id="apidoc.element.knockout.jqueryTmplTemplateEngine.prototype.constructor">
        function <span class="apidocSignatureSpan">knockout.jqueryTmplTemplateEngine.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constructor = function () {
    // Detect which version of jquery-tmpl you're using. Unfortunately jquery-tmpl
    // doesn't expose a version number, so we have to infer it.
    // Note that as of Knockout 1.3, we only support jQuery.tmpl 1.0.0pre and later,
    // which KO internally refers to as version "2", so older versions are no longer detected.
    var jQueryTmplVersion = this.jQueryTmplVersion = (function() {
        if (!jQueryInstance || !(jQueryInstance['tmpl']))
            return 0;
        // Since it exposes no official version number, we use our own numbering system. To be updated as jquery-tmpl evolves.
        try {
            if (jQueryInstance['tmpl']['tag']['tmpl']['open'].toString().indexOf('__') &gt;= 0) {
                // Since 1.0.0pre, custom tags should append markup to an array called "__"
                return 2; // Final version of jquery.tmpl
            }
        } catch(ex) { /* Apparently not the version we were looking for */ }

        return 1; // Any older version that we don't support
    })();

    function ensureHasReferencedJQueryTemplates() {
        if (jQueryTmplVersion &lt; 2)
            throw new Error("Your version of jQuery.tmpl is too old. Please upgrade to jQuery.tmpl 1.0.0pre or later.");
    }

    function executeTemplate(compiledTemplate, data, jQueryTemplateOptions) {
        return jQueryInstance['tmpl'](compiledTemplate, data, jQueryTemplateOptions);
    }

    this['renderTemplateSource'] = function(templateSource, bindingContext, options, templateDocument) {
        templateDocument = templateDocument || document;
        options = options || {};
        ensureHasReferencedJQueryTemplates();

        // Ensure we have stored a precompiled version of this template (don't want to reparse on every render)
        var precompiled = templateSource['data']('precompiled');
        if (!precompiled) {
            var templateText = templateSource['text']() || "";
            // Wrap in "with($whatever.koBindingContext) { ... }"
            templateText = "{{ko_with $item.koBindingContext}}" + templateText + "{{/ko_with}}";

            precompiled = jQueryInstance['template'](null, templateText);
            templateSource['data']('precompiled', precompiled);
        }

        var data = [bindingContext['$data']]; // Prewrap the data in an array to stop jquery.tmpl from trying to unwrap any arrays
        var jQueryTemplateOptions = jQueryInstance['extend']({ 'koBindingContext': bindingContext }, options['templateOptions']);

        var resultNodes = executeTemplate(precompiled, data, jQueryTemplateOptions);
        resultNodes['appendTo'](templateDocument.createElement("div")); // Using "appendTo" forces jQuery/jQuery.tmpl to perform
 necessary cleanup work

        jQueryInstance['fragments'] = {}; // Clear jQuery's fragment cache to avoid a memory leak after a large number of template
 renders
        return resultNodes;
    };

    this['createJavaScriptEvaluatorBlock'] = function(script) {
        return "{{ko_code ((function() { return " + script + " })()) }}";
    };

    this['addTemplate'] = function(templateName, templateMarkup) {
        document.write("&lt;script type='text/html' id='" + templateName + "'&gt;" + templateMarkup + "&lt;" + "/script&gt;");
    };

    if (jQueryTmplVersion &gt; 0) {
        jQueryInstance['tmpl']['tag']['ko_code'] = {
            open: "__.push($1 || '');"
        };
        jQueryInstance['tmpl']['tag']['ko_with'] = {
            open: "with($1) {",
            close: "} "
        };
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.knockout.memoization" id="apidoc.module.knockout.memoization">module knockout.memoization</a></h1>


    <h2>
        <a href="#apidoc.element.knockout.memoization.memoize" id="apidoc.element.knockout.memoization.memoize">
        function <span class="apidocSignatureSpan">knockout.memoization.</span>memoize
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">memoize = function (callback) {
    if (typeof callback != "function")
        throw new Error("You can only pass a function to ko.memoization.memoize()");
    var memoId = generateRandomId();
    memos[memoId] = callback;
    return "&lt;!--[ko_memo:" + memoId + "]--&gt;";
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.memoization.parseMemoText" id="apidoc.element.knockout.memoization.parseMemoText">
        function <span class="apidocSignatureSpan">knockout.memoization.</span>parseMemoText
        <span class="apidocSignatureSpan">(memoText)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseMemoText = function (memoText) {
    var match = memoText.match(/^\[ko_memo\:(.*?)\]$/);
    return match ? match[1] : null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.memoization.unmemoize" id="apidoc.element.knockout.memoization.unmemoize">
        function <span class="apidocSignatureSpan">knockout.memoization.</span>unmemoize
        <span class="apidocSignatureSpan">(memoId, callbackParams)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unmemoize = function (memoId, callbackParams) {
    var callback = memos[memoId];
    if (callback === undefined)
        throw new Error("Couldn't find any memo with ID " + memoId + ". Perhaps it's already been unmemoized.");
    try {
        callback.apply(null, callbackParams || []);
        return true;
    }
    finally { delete memos[memoId]; }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.memoization.unmemoizeDomNodeAndDescendants" id="apidoc.element.knockout.memoization.unmemoizeDomNodeAndDescendants">
        function <span class="apidocSignatureSpan">knockout.memoization.</span>unmemoizeDomNodeAndDescendants
        <span class="apidocSignatureSpan">(domNode, extraCallbackParamsArray)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unmemoizeDomNodeAndDescendants = function (domNode, extraCallbackParamsArray) {
    var memos = [];
    findMemoNodes(domNode, memos);
    for (var i = 0, j = memos.length; i &lt; j; i++) {
        var node = memos[i].domNode;
        var combinedParams = [node];
        if (extraCallbackParamsArray)
            ko.utils.arrayPushAll(combinedParams, extraCallbackParamsArray);
        ko.memoization.unmemoize(memos[i].memoId, combinedParams);
        node.nodeValue = ""; // Neuter this node so we don't try to unmemoize it again
        if (node.parentNode)
            node.parentNode.removeChild(node); // If possible, erase it totally (not always possible - someone else might just hold
 a reference to it then call unmemoizeDomNodeAndDescendants again)
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.knockout.nativeTemplateEngine" id="apidoc.module.knockout.nativeTemplateEngine">module knockout.nativeTemplateEngine</a></h1>


    <h2>
        <a href="#apidoc.element.knockout.nativeTemplateEngine.nativeTemplateEngine" id="apidoc.element.knockout.nativeTemplateEngine.nativeTemplateEngine">
        function <span class="apidocSignatureSpan">knockout.</span>nativeTemplateEngine
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nativeTemplateEngine = function () {
    this['allowTemplateRewriting'] = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.knockout.nativeTemplateEngine.prototype" id="apidoc.module.knockout.nativeTemplateEngine.prototype">module knockout.nativeTemplateEngine.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.knockout.nativeTemplateEngine.prototype.constructor" id="apidoc.element.knockout.nativeTemplateEngine.prototype.constructor">
        function <span class="apidocSignatureSpan">knockout.nativeTemplateEngine.prototype.</span>constructor
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constructor = function () {
    this['allowTemplateRewriting'] = false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.nativeTemplateEngine.prototype.renderTemplateSource" id="apidoc.element.knockout.nativeTemplateEngine.prototype.renderTemplateSource">
        function <span class="apidocSignatureSpan">knockout.nativeTemplateEngine.prototype.</span>renderTemplateSource
        <span class="apidocSignatureSpan">(templateSource, bindingContext, options, templateDocument)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">renderTemplateSource = function (templateSource, bindingContext, options, templateDocument) {
    var useNodesIfAvailable = !(ko.utils.ieVersion &lt; 9), // IE&lt;9 cloneNode doesn't work properly
        templateNodesFunc = useNodesIfAvailable ? templateSource['nodes'] : null,
        templateNodes = templateNodesFunc ? templateSource['nodes']() : null;

    if (templateNodes) {
        return ko.utils.makeArray(templateNodes.cloneNode(true).childNodes);
    } else {
        var templateText = templateSource['text']();
        return ko.utils.parseHtmlFragment(templateText, templateDocument);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.knockout.selectExtensions" id="apidoc.module.knockout.selectExtensions">module knockout.selectExtensions</a></h1>


    <h2>
        <a href="#apidoc.element.knockout.selectExtensions.readValue" id="apidoc.element.knockout.selectExtensions.readValue">
        function <span class="apidocSignatureSpan">knockout.selectExtensions.</span>readValue
        <span class="apidocSignatureSpan">(element)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">readValue = function (element) {
    switch (ko.utils.tagNameLower(element)) {
        case 'option':
            if (element[hasDomDataExpandoProperty] === true)
                return ko.utils.domData.get(element, ko.bindingHandlers.options.optionValueDomDataKey);
            return ko.utils.ieVersion &lt;= 7
                ? (element.getAttributeNode('value') &amp;&amp; element.getAttributeNode('value').specified ? element.value : element.text
)
                : element.value;
        case 'select':
            return element.selectedIndex &gt;= 0 ? ko.selectExtensions.readValue(element.options[element.selectedIndex]) : undefined
;
        default:
            return element.value;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.selectExtensions.writeValue" id="apidoc.element.knockout.selectExtensions.writeValue">
        function <span class="apidocSignatureSpan">knockout.selectExtensions.</span>writeValue
        <span class="apidocSignatureSpan">(element, value, allowUnset)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">writeValue = function (element, value, allowUnset) {
    switch (ko.utils.tagNameLower(element)) {
        case 'option':
            switch(typeof value) {
                case "string":
                    ko.utils.domData.set(element, ko.bindingHandlers.options.optionValueDomDataKey, undefined);
                    if (hasDomDataExpandoProperty in element) { // IE &lt;= 8 throws errors if you delete non-existent properties from
 a DOM node
                        delete element[hasDomDataExpandoProperty];
                    }
                    element.value = value;
                    break;
                default:
                    // Store arbitrary object using DomData
                    ko.utils.domData.set(element, ko.bindingHandlers.options.optionValueDomDataKey, value);
                    element[hasDomDataExpandoProperty] = true;

                    // Special treatment of numbers is just for backward compatibility. KO 1.2.1 wrote numerical values to element
.value.
                    element.value = typeof value === "number" ? value : "";
                    break;
            }
            break;
        case 'select':
            if (value === "" || value === null)       // A blank string or null value will select the caption
                value = undefined;
            var selection = -1;
            for (var i = 0, n = element.options.length, optionValue; i &lt; n; ++i) {
                optionValue = ko.selectExtensions.readValue(element.options[i]);
                // Include special check to handle selecting a caption with a blank string value
                if (optionValue == value || (optionValue == "" &amp;&amp; value === undefined)) {
                    selection = i;
                    break;
                }
            }
            if (allowUnset || selection &gt;= 0 || (value === undefined &amp;&amp; element.size &gt; 1)) {
                element.selectedIndex = selection;
            }
            break;
        default:
            if ((value === null) || (value === undefined))
                value = "";
            element.value = value;
            break;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.knockout.subscription" id="apidoc.module.knockout.subscription">module knockout.subscription</a></h1>


    <h2>
        <a href="#apidoc.element.knockout.subscription.subscription" id="apidoc.element.knockout.subscription.subscription">
        function <span class="apidocSignatureSpan">knockout.</span>subscription
        <span class="apidocSignatureSpan">(target, callback, disposeCallback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">subscription = function (target, callback, disposeCallback) {
    this._target = target;
    this.callback = callback;
    this.disposeCallback = disposeCallback;
    this.isDisposed = false;
    ko.exportProperty(this, 'dispose', this.dispose);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.knockout.subscription.prototype" id="apidoc.module.knockout.subscription.prototype">module knockout.subscription.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.knockout.subscription.prototype.dispose" id="apidoc.element.knockout.subscription.prototype.dispose">
        function <span class="apidocSignatureSpan">knockout.subscription.prototype.</span>dispose
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">dispose = function () {
    this.isDisposed = true;
    this.disposeCallback();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.knockout.tasks" id="apidoc.module.knockout.tasks">module knockout.tasks</a></h1>


    <h2>
        <a href="#apidoc.element.knockout.tasks.cancel" id="apidoc.element.knockout.tasks.cancel">
        function <span class="apidocSignatureSpan">knockout.tasks.</span>cancel
        <span class="apidocSignatureSpan">(handle)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cancel = function (handle) {
    var index = handle - (nextHandle - taskQueueLength);
    if (index &gt;= nextIndexToProcess &amp;&amp; index &lt; taskQueueLength) {
        taskQueue[index] = null;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.tasks.resetForTesting" id="apidoc.element.knockout.tasks.resetForTesting">
        function <span class="apidocSignatureSpan">knockout.tasks.</span>resetForTesting
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">resetForTesting = function () {
    var length = taskQueueLength - nextIndexToProcess;
    nextIndexToProcess = taskQueueLength = taskQueue.length = 0;
    return length;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.tasks.runEarly" id="apidoc.element.knockout.tasks.runEarly">
        function <span class="apidocSignatureSpan">knockout.tasks.</span>runEarly
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function processTasks() {
    if (taskQueueLength) {
        // Each mark represents the end of a logical group of tasks and the number of these groups is
        // limited to prevent unchecked recursion.
        var mark = taskQueueLength, countMarks = 0;

        // nextIndexToProcess keeps track of where we are in the queue; processTasks can be called recursively without issue
        for (var task; nextIndexToProcess &lt; taskQueueLength; ) {
            if (task = taskQueue[nextIndexToProcess++]) {
                if (nextIndexToProcess &gt; mark) {
                    if (++countMarks &gt;= 5000) {
                        nextIndexToProcess = taskQueueLength;   // skip all tasks remaining in the queue since any of them could
 be causing the recursion
                        ko.utils.deferError(Error("'Too much recursion' after processing " + countMarks + " task groups."));
                        break;
                    }
                    mark = taskQueueLength;
                }
                try {
                    task();
                } catch (ex) {
                    ko.utils.deferError(ex);
                }
            }
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.tasks.schedule" id="apidoc.element.knockout.tasks.schedule">
        function <span class="apidocSignatureSpan">knockout.tasks.</span>schedule
        <span class="apidocSignatureSpan">(func)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">schedule = function (func) {
    if (!taskQueueLength) {
        scheduleTaskProcessing();
    }

    taskQueue[taskQueueLength++] = func;
    return nextHandle++;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.tasks.scheduler" id="apidoc.element.knockout.tasks.scheduler">
        function <span class="apidocSignatureSpan">knockout.tasks.</span>scheduler
        <span class="apidocSignatureSpan">(callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">scheduler = function (callback) {
    setTimeout(callback, 0);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.knockout.templateEngine" id="apidoc.module.knockout.templateEngine">module knockout.templateEngine</a></h1>


    <h2>
        <a href="#apidoc.element.knockout.templateEngine.templateEngine" id="apidoc.element.knockout.templateEngine.templateEngine">
        function <span class="apidocSignatureSpan">knockout.</span>templateEngine
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">templateEngine = function () { }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.knockout.templateEngine.prototype" id="apidoc.module.knockout.templateEngine.prototype">module knockout.templateEngine.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.knockout.templateEngine.prototype.createJavaScriptEvaluatorBlock" id="apidoc.element.knockout.templateEngine.prototype.createJavaScriptEvaluatorBlock">
        function <span class="apidocSignatureSpan">knockout.templateEngine.prototype.</span>createJavaScriptEvaluatorBlock
        <span class="apidocSignatureSpan">(script)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createJavaScriptEvaluatorBlock = function (script) {
    throw new Error("Override createJavaScriptEvaluatorBlock");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.templateEngine.prototype.isTemplateRewritten" id="apidoc.element.knockout.templateEngine.prototype.isTemplateRewritten">
        function <span class="apidocSignatureSpan">knockout.templateEngine.prototype.</span>isTemplateRewritten
        <span class="apidocSignatureSpan">(template, templateDocument)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">isTemplateRewritten = function (template, templateDocument) {
    // Skip rewriting if requested
    if (this['allowTemplateRewriting'] === false)
        return true;
    return this['makeTemplateSource'](template, templateDocument)['data']("isRewritten");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.templateEngine.prototype.makeTemplateSource" id="apidoc.element.knockout.templateEngine.prototype.makeTemplateSource">
        function <span class="apidocSignatureSpan">knockout.templateEngine.prototype.</span>makeTemplateSource
        <span class="apidocSignatureSpan">(template, templateDocument)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeTemplateSource = function (template, templateDocument) {
    // Named template
    if (typeof template == "string") {
        templateDocument = templateDocument || document;
        var elem = templateDocument.getElementById(template);
        if (!elem)
            throw new Error("Cannot find template with ID " + template);
        return new ko.templateSources.domElement(elem);
    } else if ((template.nodeType == 1) || (template.nodeType == 8)) {
        // Anonymous template
        return new ko.templateSources.anonymousTemplate(template);
    } else
        throw new Error("Unknown template type: " + template);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.templateEngine.prototype.renderTemplate" id="apidoc.element.knockout.templateEngine.prototype.renderTemplate">
        function <span class="apidocSignatureSpan">knockout.templateEngine.prototype.</span>renderTemplate
        <span class="apidocSignatureSpan">(template, bindingContext, options, templateDocument)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">renderTemplate = function (template, bindingContext, options, templateDocument) {
    var templateSource = this['makeTemplateSource'](template, templateDocument);
    return this['renderTemplateSource'](templateSource, bindingContext, options, templateDocument);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.templateEngine.prototype.renderTemplateSource" id="apidoc.element.knockout.templateEngine.prototype.renderTemplateSource">
        function <span class="apidocSignatureSpan">knockout.templateEngine.prototype.</span>renderTemplateSource
        <span class="apidocSignatureSpan">(templateSource, bindingContext, options, templateDocument)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">renderTemplateSource = function (templateSource, bindingContext, options, templateDocument) {
    throw new Error("Override renderTemplateSource");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.templateEngine.prototype.rewriteTemplate" id="apidoc.element.knockout.templateEngine.prototype.rewriteTemplate">
        function <span class="apidocSignatureSpan">knockout.templateEngine.prototype.</span>rewriteTemplate
        <span class="apidocSignatureSpan">(template, rewriterCallback, templateDocument)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">rewriteTemplate = function (template, rewriterCallback, templateDocument) {
    var templateSource = this['makeTemplateSource'](template, templateDocument);
    var rewritten = rewriterCallback(templateSource['text']());
    templateSource['text'](rewritten);
    templateSource['data']("isRewritten", true);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.knockout.templateRewriting" id="apidoc.module.knockout.templateRewriting">module knockout.templateRewriting</a></h1>


    <h2>
        <a href="#apidoc.element.knockout.templateRewriting.applyMemoizedBindingsToNextSibling" id="apidoc.element.knockout.templateRewriting.applyMemoizedBindingsToNextSibling">
        function <span class="apidocSignatureSpan">knockout.templateRewriting.</span>applyMemoizedBindingsToNextSibling
        <span class="apidocSignatureSpan">(bindings, nodeName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">applyMemoizedBindingsToNextSibling = function (bindings, nodeName) {
    return ko.memoization.memoize(function (domNode, bindingContext) {
        var nodeToBind = domNode.nextSibling;
        if (nodeToBind &amp;&amp; nodeToBind.nodeName.toLowerCase() === nodeName) {
            ko.applyBindingAccessorsToNode(nodeToBind, bindings, bindingContext);
        }
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.templateRewriting.ensureTemplateIsRewritten" id="apidoc.element.knockout.templateRewriting.ensureTemplateIsRewritten">
        function <span class="apidocSignatureSpan">knockout.templateRewriting.</span>ensureTemplateIsRewritten
        <span class="apidocSignatureSpan">(template, templateEngine, templateDocument)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ensureTemplateIsRewritten = function (template, templateEngine, templateDocument) {
    if (!templateEngine['isTemplateRewritten'](template, templateDocument))
        templateEngine['rewriteTemplate'](template, function (htmlString) {
            return ko.templateRewriting.memoizeBindingAttributeSyntax(htmlString, templateEngine);
        }, templateDocument);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.templateRewriting.memoizeBindingAttributeSyntax" id="apidoc.element.knockout.templateRewriting.memoizeBindingAttributeSyntax">
        function <span class="apidocSignatureSpan">knockout.templateRewriting.</span>memoizeBindingAttributeSyntax
        <span class="apidocSignatureSpan">(htmlString, templateEngine)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">memoizeBindingAttributeSyntax = function (htmlString, templateEngine) {
    return htmlString.replace(memoizeDataBindingAttributeSyntaxRegex, function () {
        return constructMemoizedTagReplacement(/* dataBindAttributeValue: */ arguments[4], /* tagToRetain: */ arguments[1], /* nodeName
: */ arguments[2], templateEngine);
    }).replace(memoizeVirtualContainerBindingSyntaxRegex, function() {
        return constructMemoizedTagReplacement(/* dataBindAttributeValue: */ arguments[1], /* tagToRetain: */ "&lt;!-- ko --&gt;", /*
nodeName: */ "#comment", templateEngine);
    });
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.knockout.templateSources" id="apidoc.module.knockout.templateSources">module knockout.templateSources</a></h1>


    <h2>
        <a href="#apidoc.element.knockout.templateSources.anonymousTemplate" id="apidoc.element.knockout.templateSources.anonymousTemplate">
        function <span class="apidocSignatureSpan">knockout.templateSources.</span>anonymousTemplate
        <span class="apidocSignatureSpan">(element)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">anonymousTemplate = function (element) {
    this.domElement = element;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.templateSources.domElement" id="apidoc.element.knockout.templateSources.domElement">
        function <span class="apidocSignatureSpan">knockout.templateSources.</span>domElement
        <span class="apidocSignatureSpan">(element)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">domElement = function (element) {
    this.domElement = element;

    if (element) {
        var tagNameLower = ko.utils.tagNameLower(element);
        this.templateType =
            tagNameLower === "script" ? templateScript :
            tagNameLower === "textarea" ? templateTextArea :
                // For browsers with proper &lt;template&gt; element support, where the .content property gives a document fragment
            tagNameLower == "template" &amp;&amp; element.content &amp;&amp; element.content.nodeType === 11 ? templateTemplate :
            templateElement;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.knockout.templateSources.anonymousTemplate" id="apidoc.module.knockout.templateSources.anonymousTemplate">module knockout.templateSources.anonymousTemplate</a></h1>


    <h2>
        <a href="#apidoc.element.knockout.templateSources.anonymousTemplate.anonymousTemplate" id="apidoc.element.knockout.templateSources.anonymousTemplate.anonymousTemplate">
        function <span class="apidocSignatureSpan">knockout.templateSources.</span>anonymousTemplate
        <span class="apidocSignatureSpan">(element)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">anonymousTemplate = function (element) {
    this.domElement = element;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.knockout.templateSources.anonymousTemplate.prototype" id="apidoc.module.knockout.templateSources.anonymousTemplate.prototype">module knockout.templateSources.anonymousTemplate.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.knockout.templateSources.anonymousTemplate.prototype.constructor" id="apidoc.element.knockout.templateSources.anonymousTemplate.prototype.constructor">
        function <span class="apidocSignatureSpan">knockout.templateSources.anonymousTemplate.prototype.</span>constructor
        <span class="apidocSignatureSpan">(element)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">constructor = function (element) {
    this.domElement = element;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.templateSources.anonymousTemplate.prototype.text" id="apidoc.element.knockout.templateSources.anonymousTemplate.prototype.text">
        function <span class="apidocSignatureSpan">knockout.templateSources.anonymousTemplate.prototype.</span>text
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">text = function () {
    if (arguments.length == 0) {
        var templateData = getTemplateDomData(this.domElement);
        if (templateData.textData === undefined &amp;&amp; templateData.containerData)
            templateData.textData = templateData.containerData.innerHTML;
        return templateData.textData;
    } else {
        var valueToWrite = arguments[0];
        setTemplateDomData(this.domElement, {textData: valueToWrite});
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.knockout.templateSources.domElement" id="apidoc.module.knockout.templateSources.domElement">module knockout.templateSources.domElement</a></h1>


    <h2>
        <a href="#apidoc.element.knockout.templateSources.domElement.domElement" id="apidoc.element.knockout.templateSources.domElement.domElement">
        function <span class="apidocSignatureSpan">knockout.templateSources.</span>domElement
        <span class="apidocSignatureSpan">(element)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">domElement = function (element) {
    this.domElement = element;

    if (element) {
        var tagNameLower = ko.utils.tagNameLower(element);
        this.templateType =
            tagNameLower === "script" ? templateScript :
            tagNameLower === "textarea" ? templateTextArea :
                // For browsers with proper &lt;template&gt; element support, where the .content property gives a document fragment
            tagNameLower == "template" &amp;&amp; element.content &amp;&amp; element.content.nodeType === 11 ? templateTemplate :
            templateElement;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.knockout.templateSources.domElement.prototype" id="apidoc.module.knockout.templateSources.domElement.prototype">module knockout.templateSources.domElement.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.knockout.templateSources.domElement.prototype.data" id="apidoc.element.knockout.templateSources.domElement.prototype.data">
        function <span class="apidocSignatureSpan">knockout.templateSources.domElement.prototype.</span>data
        <span class="apidocSignatureSpan">(key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">data = function (key) {
    if (arguments.length === 1) {
        return ko.utils.domData.get(this.domElement, dataDomDataPrefix + key);
    } else {
        ko.utils.domData.set(this.domElement, dataDomDataPrefix + key, arguments[1]);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.templateSources.domElement.prototype.nodes" id="apidoc.element.knockout.templateSources.domElement.prototype.nodes">
        function <span class="apidocSignatureSpan">knockout.templateSources.domElement.prototype.</span>nodes
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nodes = function () {
    var element = this.domElement;
    if (arguments.length == 0) {
        var templateData = getTemplateDomData(element),
            containerData = templateData.containerData;
        return containerData || (
            this.templateType === templateTemplate ? element.content :
            this.templateType === templateElement ? element :
            undefined);
    } else {
        var valueToWrite = arguments[0];
        setTemplateDomData(element, {containerData: valueToWrite});
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.templateSources.domElement.prototype.text" id="apidoc.element.knockout.templateSources.domElement.prototype.text">
        function <span class="apidocSignatureSpan">knockout.templateSources.domElement.prototype.</span>text
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">text = function () {
    var elemContentsProperty = this.templateType === templateScript ? "text"
                             : this.templateType === templateTextArea ? "value"
                             : "innerHTML";

    if (arguments.length == 0) {
        return this.domElement[elemContentsProperty];
    } else {
        var valueToWrite = arguments[0];
        if (elemContentsProperty === "innerHTML")
            ko.utils.setHtml(this.domElement, valueToWrite);
        else
            this.domElement[elemContentsProperty] = valueToWrite;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.knockout.utils" id="apidoc.module.knockout.utils">module knockout.utils</a></h1>








    <h2>
        <a href="#apidoc.element.knockout.utils.addOrRemoveItem" id="apidoc.element.knockout.utils.addOrRemoveItem">
        function <span class="apidocSignatureSpan">knockout.utils.</span>addOrRemoveItem
        <span class="apidocSignatureSpan">(array, value, included)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addOrRemoveItem = function (array, value, included) {
    var existingEntryIndex = ko.utils.arrayIndexOf(ko.utils.peekObservable(array), value);
    if (existingEntryIndex &lt; 0) {
        if (included)
            array.push(value);
    } else {
        if (!included)
            array.splice(existingEntryIndex, 1);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.utils.anyDomNodeIsAttachedToDocument" id="apidoc.element.knockout.utils.anyDomNodeIsAttachedToDocument">
        function <span class="apidocSignatureSpan">knockout.utils.</span>anyDomNodeIsAttachedToDocument
        <span class="apidocSignatureSpan">(nodes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">anyDomNodeIsAttachedToDocument = function (nodes) {
    return !!ko.utils.arrayFirst(nodes, ko.utils.domNodeIsAttachedToDocument);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.utils.arrayFilter" id="apidoc.element.knockout.utils.arrayFilter">
        function <span class="apidocSignatureSpan">knockout.utils.</span>arrayFilter
        <span class="apidocSignatureSpan">(array, predicate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">arrayFilter = function (array, predicate) {
    array = array || [];
    var result = [];
    for (var i = 0, j = array.length; i &lt; j; i++)
        if (predicate(array[i], i))
            result.push(array[i]);
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.utils.arrayFirst" id="apidoc.element.knockout.utils.arrayFirst">
        function <span class="apidocSignatureSpan">knockout.utils.</span>arrayFirst
        <span class="apidocSignatureSpan">(array, predicate, predicateOwner)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">arrayFirst = function (array, predicate, predicateOwner) {
    for (var i = 0, j = array.length; i &lt; j; i++)
        if (predicate.call(predicateOwner, array[i], i))
            return array[i];
    return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.utils.arrayForEach" id="apidoc.element.knockout.utils.arrayForEach">
        function <span class="apidocSignatureSpan">knockout.utils.</span>arrayForEach
        <span class="apidocSignatureSpan">(array, action)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">arrayForEach = function (array, action) {
    for (var i = 0, j = array.length; i &lt; j; i++)
        action(array[i], i);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.utils.arrayGetDistinctValues" id="apidoc.element.knockout.utils.arrayGetDistinctValues">
        function <span class="apidocSignatureSpan">knockout.utils.</span>arrayGetDistinctValues
        <span class="apidocSignatureSpan">(array)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">arrayGetDistinctValues = function (array) {
    array = array || [];
    var result = [];
    for (var i = 0, j = array.length; i &lt; j; i++) {
        if (ko.utils.arrayIndexOf(result, array[i]) &lt; 0)
            result.push(array[i]);
    }
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.utils.arrayIndexOf" id="apidoc.element.knockout.utils.arrayIndexOf">
        function <span class="apidocSignatureSpan">knockout.utils.</span>arrayIndexOf
        <span class="apidocSignatureSpan">(array, item)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">arrayIndexOf = function (array, item) {
    if (typeof Array.prototype.indexOf == "function")
        return Array.prototype.indexOf.call(array, item);
    for (var i = 0, j = array.length; i &lt; j; i++)
        if (array[i] === item)
            return i;
    return -1;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.utils.arrayMap" id="apidoc.element.knockout.utils.arrayMap">
        function <span class="apidocSignatureSpan">knockout.utils.</span>arrayMap
        <span class="apidocSignatureSpan">(array, mapping)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">arrayMap = function (array, mapping) {
    array = array || [];
    var result = [];
    for (var i = 0, j = array.length; i &lt; j; i++)
        result.push(mapping(array[i], i));
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.utils.arrayPushAll" id="apidoc.element.knockout.utils.arrayPushAll">
        function <span class="apidocSignatureSpan">knockout.utils.</span>arrayPushAll
        <span class="apidocSignatureSpan">(array, valuesToPush)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">arrayPushAll = function (array, valuesToPush) {
    if (valuesToPush instanceof Array)
        array.push.apply(array, valuesToPush);
    else
        for (var i = 0, j = valuesToPush.length; i &lt; j; i++)
            array.push(valuesToPush[i]);
    return array;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.utils.arrayRemoveItem" id="apidoc.element.knockout.utils.arrayRemoveItem">
        function <span class="apidocSignatureSpan">knockout.utils.</span>arrayRemoveItem
        <span class="apidocSignatureSpan">(array, itemToRemove)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">arrayRemoveItem = function (array, itemToRemove) {
    var index = ko.utils.arrayIndexOf(array, itemToRemove);
    if (index &gt; 0) {
        array.splice(index, 1);
    }
    else if (index === 0) {
        array.shift();
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.utils.catchFunctionErrors" id="apidoc.element.knockout.utils.catchFunctionErrors">
        function <span class="apidocSignatureSpan">knockout.utils.</span>catchFunctionErrors
        <span class="apidocSignatureSpan">(delegate)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">catchFunctionErrors = function (delegate) {
    return ko['onError'] ? function () {
        try {
            return delegate.apply(this, arguments);
        } catch (e) {
            ko['onError'] &amp;&amp; ko['onError'](e);
            throw e;
        }
    } : delegate;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.utils.cloneNodes" id="apidoc.element.knockout.utils.cloneNodes">
        function <span class="apidocSignatureSpan">knockout.utils.</span>cloneNodes
        <span class="apidocSignatureSpan">(nodesArray, shouldCleanNodes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cloneNodes = function (nodesArray, shouldCleanNodes) {
    for (var i = 0, j = nodesArray.length, newNodesArray = []; i &lt; j; i++) {
        var clonedNode = nodesArray[i].cloneNode(true);
        newNodesArray.push(shouldCleanNodes ? ko.cleanNode(clonedNode) : clonedNode);
    }
    return newNodesArray;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.utils.compareArrays" id="apidoc.element.knockout.utils.compareArrays">
        function <span class="apidocSignatureSpan">knockout.utils.</span>compareArrays
        <span class="apidocSignatureSpan">(oldArray, newArray, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function compareArrays(oldArray, newArray, options) {
    // For backward compatibility, if the third arg is actually a bool, interpret
    // it as the old parameter 'dontLimitMoves'. Newer code should use { dontLimitMoves: true }.
    options = (typeof options === 'boolean') ? { 'dontLimitMoves': options } : (options || {});
    oldArray = oldArray || [];
    newArray = newArray || [];

    if (oldArray.length &lt; newArray.length)
        return compareSmallArrayToBigArray(oldArray, newArray, statusNotInOld, statusNotInNew, options);
    else
        return compareSmallArrayToBigArray(newArray, oldArray, statusNotInNew, statusNotInOld, options);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.utils.createSymbolOrString" id="apidoc.element.knockout.utils.createSymbolOrString">
        function <span class="apidocSignatureSpan">knockout.utils.</span>createSymbolOrString
        <span class="apidocSignatureSpan">(identifier)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">createSymbolOrString = function (identifier) {
    return canUseSymbols ? Symbol(identifier) : identifier;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.utils.deferError" id="apidoc.element.knockout.utils.deferError">
        function <span class="apidocSignatureSpan">knockout.utils.</span>deferError
        <span class="apidocSignatureSpan">(error)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">deferError = function (error) {
    setTimeout(function () {
        ko['onError'] &amp;&amp; ko['onError'](error);
        throw error;
    }, 0);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.utils.domNodeIsAttachedToDocument" id="apidoc.element.knockout.utils.domNodeIsAttachedToDocument">
        function <span class="apidocSignatureSpan">knockout.utils.</span>domNodeIsAttachedToDocument
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">domNodeIsAttachedToDocument = function (node) {
    return ko.utils.domNodeIsContainedBy(node, node.ownerDocument.documentElement);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.utils.domNodeIsContainedBy" id="apidoc.element.knockout.utils.domNodeIsContainedBy">
        function <span class="apidocSignatureSpan">knockout.utils.</span>domNodeIsContainedBy
        <span class="apidocSignatureSpan">(node, containedByNode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">domNodeIsContainedBy = function (node, containedByNode) {
    if (node === containedByNode)
        return true;
    if (node.nodeType === 11)
        return false; // Fixes issue #1162 - can't use node.contains for document fragments on IE8
    if (containedByNode.contains)
        return containedByNode.contains(node.nodeType === 3 ? node.parentNode : node);
    if (containedByNode.compareDocumentPosition)
        return (containedByNode.compareDocumentPosition(node) &amp; 16) == 16;
    while (node &amp;&amp; node != containedByNode) {
        node = node.parentNode;
    }
    return !!node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.utils.emptyDomNode" id="apidoc.element.knockout.utils.emptyDomNode">
        function <span class="apidocSignatureSpan">knockout.utils.</span>emptyDomNode
        <span class="apidocSignatureSpan">(domNode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">emptyDomNode = function (domNode) {
    while (domNode.firstChild) {
        ko.removeNode(domNode.firstChild);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.utils.ensureSelectElementIsRenderedCorrectly" id="apidoc.element.knockout.utils.ensureSelectElementIsRenderedCorrectly">
        function <span class="apidocSignatureSpan">knockout.utils.</span>ensureSelectElementIsRenderedCorrectly
        <span class="apidocSignatureSpan">(selectElement)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">ensureSelectElementIsRenderedCorrectly = function (selectElement) {
    // Workaround for IE9 rendering bug - it doesn't reliably display all the text in dynamically-added select boxes unless you
force it to re-render by updating the width.
    // (See https://github.com/SteveSanderson/knockout/issues/312, http://stackoverflow.com/questions/5908494/select-only-shows-
first-char-of-selected-option)
    // Also fixes IE7 and IE8 bug that causes selects to be zero width if enclosed by 'if' or 'with'. (See issue #839)
    if (ieVersion) {
        var originalWidth = selectElement.style.width;
        selectElement.style.width = 0;
        selectElement.style.width = originalWidth;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.utils.extend" id="apidoc.element.knockout.utils.extend">
        function <span class="apidocSignatureSpan">knockout.utils.</span>extend
        <span class="apidocSignatureSpan">(target, source)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function extend(target, source) {
    if (source) {
        for(var prop in source) {
            if(source.hasOwnProperty(prop)) {
                target[prop] = source[prop];
            }
        }
    }
    return target;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.utils.findMovesInArrayComparison" id="apidoc.element.knockout.utils.findMovesInArrayComparison">
        function <span class="apidocSignatureSpan">knockout.utils.</span>findMovesInArrayComparison
        <span class="apidocSignatureSpan">(left, right, limitFailedCompares)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">findMovesInArrayComparison = function (left, right, limitFailedCompares) {
    if (left.length &amp;&amp; right.length) {
        var failedCompares, l, r, leftItem, rightItem;
        for (failedCompares = l = 0; (!limitFailedCompares || failedCompares &lt; limitFailedCompares) &amp;&amp; (leftItem = left[l]); ++l
) {
            for (r = 0; rightItem = right[r]; ++r) {
                if (leftItem['value'] === rightItem['value']) {
                    leftItem['moved'] = rightItem['index'];
                    rightItem['moved'] = leftItem['index'];
                    right.splice(r, 1);         // This item is marked as moved; so remove it from right list
                    failedCompares = r = 0;     // Reset failed compares count because we're checking for consecutive failures
                    break;
                }
            }
            failedCompares += r;
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.utils.fixUpContinuousNodeArray" id="apidoc.element.knockout.utils.fixUpContinuousNodeArray">
        function <span class="apidocSignatureSpan">knockout.utils.</span>fixUpContinuousNodeArray
        <span class="apidocSignatureSpan">(continuousNodeArray, parentNode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fixUpContinuousNodeArray = function (continuousNodeArray, parentNode) {
    // Before acting on a set of nodes that were previously outputted by a template function, we have to reconcile
    // them against what is in the DOM right now. It may be that some of the nodes have already been removed, or that
    // new nodes might have been inserted in the middle, for example by a binding. Also, there may previously have been
    // leading comment nodes (created by rewritten string-based templates) that have since been removed during binding.
    // So, this function translates the old "map" output array into its best guess of the set of current DOM nodes.
    //
    // Rules:
    //   [A] Any leading nodes that have been removed should be ignored
    //       These most likely correspond to memoization nodes that were already removed during binding
    //       See https://github.com/knockout/knockout/pull/440
    //   [B] Any trailing nodes that have been remove should be ignored
    //       This prevents the code here from adding unrelated nodes to the array while processing rule [C]
    //       See https://github.com/knockout/knockout/pull/1903
    //   [C] We want to output a continuous series of nodes. So, ignore any nodes that have already been removed,
    //       and include any nodes that have been inserted among the previous collection

    if (continuousNodeArray.length) {
        // The parent node can be a virtual element; so get the real parent node
        parentNode = (parentNode.nodeType === 8 &amp;&amp; parentNode.parentNode) || parentNode;

        // Rule [A]
        while (continuousNodeArray.length &amp;&amp; continuousNodeArray[0].parentNode !== parentNode)
            continuousNodeArray.splice(0, 1);

        // Rule [B]
        while (continuousNodeArray.length &gt; 1 &amp;&amp; continuousNodeArray[continuousNodeArray.length - 1].parentNode !== parentNode)
            continuousNodeArray.length--;

        // Rule [C]
        if (continuousNodeArray.length &gt; 1) {
            var current = continuousNodeArray[0], last = continuousNodeArray[continuousNodeArray.length - 1];
            // Replace with the actual new continuous node set
            continuousNodeArray.length = 0;
            while (current !== last) {
                continuousNodeArray.push(current);
                current = current.nextSibling;
            }
            continuousNodeArray.push(last);
        }
    }
    return continuousNodeArray;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.utils.forceRefresh" id="apidoc.element.knockout.utils.forceRefresh">
        function <span class="apidocSignatureSpan">knockout.utils.</span>forceRefresh
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">forceRefresh = function (node) {
    // Workaround for an IE9 rendering bug - https://github.com/SteveSanderson/knockout/issues/209
    if (ieVersion &gt;= 9) {
        // For text nodes and comment nodes (most likely virtual elements), we will have to refresh the container
        var elem = node.nodeType == 1 ? node : node.parentNode;
        if (elem.style)
            elem.style.zoom = elem.style.zoom;
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.utils.getFormFields" id="apidoc.element.knockout.utils.getFormFields">
        function <span class="apidocSignatureSpan">knockout.utils.</span>getFormFields
        <span class="apidocSignatureSpan">(form, fieldName)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">getFormFields = function (form, fieldName) {
    var fields = ko.utils.makeArray(form.getElementsByTagName("input")).concat(ko.utils.makeArray(form.getElementsByTagName("textarea
")));
    var isMatchingField = (typeof fieldName == 'string')
        ? function(field) { return field.name === fieldName }
        : function(field) { return fieldName.test(field.name) }; // Treat fieldName as regex or object containing predicate
    var matches = [];
    for (var i = fields.length - 1; i &gt;= 0; i--) {
        if (isMatchingField(fields[i]))
            matches.push(fields[i]);
    };
    return matches;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.utils.makeArray" id="apidoc.element.knockout.utils.makeArray">
        function <span class="apidocSignatureSpan">knockout.utils.</span>makeArray
        <span class="apidocSignatureSpan">(arrayLikeObject)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">makeArray = function (arrayLikeObject) {
    var result = [];
    for (var i = 0, j = arrayLikeObject.length; i &lt; j; i++) {
        result.push(arrayLikeObject[i]);
    };
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.utils.moveCleanedNodesToContainerElement" id="apidoc.element.knockout.utils.moveCleanedNodesToContainerElement">
        function <span class="apidocSignatureSpan">knockout.utils.</span>moveCleanedNodesToContainerElement
        <span class="apidocSignatureSpan">(nodes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">moveCleanedNodesToContainerElement = function (nodes) {
    // Ensure it's a real array, as we're about to reparent the nodes and
    // we don't want the underlying collection to change while we're doing that.
    var nodesArray = ko.utils.makeArray(nodes);
    var templateDocument = (nodesArray[0] &amp;&amp; nodesArray[0].ownerDocument) || document;

    var container = templateDocument.createElement('div');
    for (var i = 0, j = nodesArray.length; i &lt; j; i++) {
        container.appendChild(ko.cleanNode(nodesArray[i]));
    }
    return container;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.utils.objectForEach" id="apidoc.element.knockout.utils.objectForEach">
        function <span class="apidocSignatureSpan">knockout.utils.</span>objectForEach
        <span class="apidocSignatureSpan">(obj, action)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function objectForEach(obj, action) {
    for (var prop in obj) {
        if (obj.hasOwnProperty(prop)) {
            action(prop, obj[prop]);
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.utils.objectMap" id="apidoc.element.knockout.utils.objectMap">
        function <span class="apidocSignatureSpan">knockout.utils.</span>objectMap
        <span class="apidocSignatureSpan">(source, mapping)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">objectMap = function (source, mapping) {
    if (!source)
        return source;
    var target = {};
    for (var prop in source) {
        if (source.hasOwnProperty(prop)) {
            target[prop] = mapping(source[prop], prop, source);
        }
    }
    return target;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.utils.parseHtmlFragment" id="apidoc.element.knockout.utils.parseHtmlFragment">
        function <span class="apidocSignatureSpan">knockout.utils.</span>parseHtmlFragment
        <span class="apidocSignatureSpan">(html, documentContext)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseHtmlFragment = function (html, documentContext) {
    return jQueryInstance ?
        jQueryHtmlParse(html, documentContext) :   // As below, benefit from jQuery's optimisations where possible
        simpleHtmlParse(html, documentContext);  // ... otherwise, this simple logic will do in most common cases.
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.utils.parseJson" id="apidoc.element.knockout.utils.parseJson">
        function <span class="apidocSignatureSpan">knockout.utils.</span>parseJson
        <span class="apidocSignatureSpan">(jsonString)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">parseJson = function (jsonString) {
    if (typeof jsonString == "string") {
        jsonString = ko.utils.stringTrim(jsonString);
        if (jsonString) {
            if (JSON &amp;&amp; JSON.parse) // Use native parsing where available
                return JSON.parse(jsonString);
            return (new Function("return " + jsonString))(); // Fallback on less safe parsing for older browsers
        }
    }
    return null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.utils.peekObservable" id="apidoc.element.knockout.utils.peekObservable">
        function <span class="apidocSignatureSpan">knockout.utils.</span>peekObservable
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">peekObservable = function (value) {
    return ko.isObservable(value) ? value.peek() : value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.utils.postJson" id="apidoc.element.knockout.utils.postJson">
        function <span class="apidocSignatureSpan">knockout.utils.</span>postJson
        <span class="apidocSignatureSpan">(urlOrForm, data, options)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">postJson = function (urlOrForm, data, options) {
    options = options || {};
    var params = options['params'] || {};
    var includeFields = options['includeFields'] || this.fieldsIncludedWithJsonPost;
    var url = urlOrForm;

    // If we were given a form, use its 'action' URL and pick out any requested field values
    if((typeof urlOrForm == 'object') &amp;&amp; (ko.utils.tagNameLower(urlOrForm) === "form")) {
        var originalForm = urlOrForm;
        url = originalForm.action;
        for (var i = includeFields.length - 1; i &gt;= 0; i--) {
            var fields = ko.utils.getFormFields(originalForm, includeFields[i]);
            for (var j = fields.length - 1; j &gt;= 0; j--)
                params[fields[j].name] = fields[j].value;
        }
    }

    data = ko.utils.unwrapObservable(data);
    var form = document.createElement("form");
    form.style.display = "none";
    form.action = url;
    form.method = "post";
    for (var key in data) {
        // Since 'data' this is a model object, we include all properties including those inherited from its prototype
        var input = document.createElement("input");
        input.type = "hidden";
        input.name = key;
        input.value = ko.utils.stringifyJson(ko.utils.unwrapObservable(data[key]));
        form.appendChild(input);
    }
    objectForEach(params, function(key, value) {
        var input = document.createElement("input");
        input.type = "hidden";
        input.name = key;
        input.value = value;
        form.appendChild(input);
    });
    document.body.appendChild(form);
    options['submitter'] ? options['submitter'](form) : form.submit();
    setTimeout(function () { form.parentNode.removeChild(form); }, 0);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.utils.range" id="apidoc.element.knockout.utils.range">
        function <span class="apidocSignatureSpan">knockout.utils.</span>range
        <span class="apidocSignatureSpan">(min, max)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">range = function (min, max) {
    min = ko.utils.unwrapObservable(min);
    max = ko.utils.unwrapObservable(max);
    var result = [];
    for (var i = min; i &lt;= max; i++)
        result.push(i);
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.utils.registerEventHandler" id="apidoc.element.knockout.utils.registerEventHandler">
        function <span class="apidocSignatureSpan">knockout.utils.</span>registerEventHandler
        <span class="apidocSignatureSpan">(element, eventType, handler)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">registerEventHandler = function (element, eventType, handler) {
    var wrappedHandler = ko.utils.catchFunctionErrors(handler);

    var mustUseAttachEvent = ieVersion &amp;&amp; eventsThatMustBeRegisteredUsingAttachEvent[eventType];
    if (!ko.options['useOnlyNativeEvents'] &amp;&amp; !mustUseAttachEvent &amp;&amp; jQueryInstance) {
        jQueryInstance(element)['bind'](eventType, wrappedHandler);
    } else if (!mustUseAttachEvent &amp;&amp; typeof element.addEventListener == "function")
        element.addEventListener(eventType, wrappedHandler, false);
    else if (typeof element.attachEvent != "undefined") {
        var attachEventHandler = function (event) { wrappedHandler.call(element, event); },
            attachEventName = "on" + eventType;
        element.attachEvent(attachEventName, attachEventHandler);

        // IE does not dispose attachEvent handlers automatically (unlike with addEventListener)
        // so to avoid leaks, we have to remove them manually. See bug #856
        ko.utils.domNodeDisposal.addDisposeCallback(element, function() {
            element.detachEvent(attachEventName, attachEventHandler);
        });
    } else
        throw new Error("Browser doesn't support addEventListener or attachEvent");
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.utils.replaceDomNodes" id="apidoc.element.knockout.utils.replaceDomNodes">
        function <span class="apidocSignatureSpan">knockout.utils.</span>replaceDomNodes
        <span class="apidocSignatureSpan">(nodeToReplaceOrNodeArray, newNodesArray)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">replaceDomNodes = function (nodeToReplaceOrNodeArray, newNodesArray) {
    var nodesToReplaceArray = nodeToReplaceOrNodeArray.nodeType ? [nodeToReplaceOrNodeArray] : nodeToReplaceOrNodeArray;
    if (nodesToReplaceArray.length &gt; 0) {
        var insertionPoint = nodesToReplaceArray[0];
        var parent = insertionPoint.parentNode;
        for (var i = 0, j = newNodesArray.length; i &lt; j; i++)
            parent.insertBefore(newNodesArray[i], insertionPoint);
        for (var i = 0, j = nodesToReplaceArray.length; i &lt; j; i++) {
            ko.removeNode(nodesToReplaceArray[i]);
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.utils.setDomNodeChildren" id="apidoc.element.knockout.utils.setDomNodeChildren">
        function <span class="apidocSignatureSpan">knockout.utils.</span>setDomNodeChildren
        <span class="apidocSignatureSpan">(domNode, childNodes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setDomNodeChildren = function (domNode, childNodes) {
    ko.utils.emptyDomNode(domNode);
    if (childNodes) {
        for (var i = 0, j = childNodes.length; i &lt; j; i++)
            domNode.appendChild(childNodes[i]);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.utils.setDomNodeChildrenFromArrayMapping" id="apidoc.element.knockout.utils.setDomNodeChildrenFromArrayMapping">
        function <span class="apidocSignatureSpan">knockout.utils.</span>setDomNodeChildrenFromArrayMapping
        <span class="apidocSignatureSpan">(domNode, array, mapping, options, callbackAfterAddingNodes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setDomNodeChildrenFromArrayMapping = function (domNode, array, mapping, options, callbackAfterAddingNodes) {
    // Compare the provided array against the previous one
    array = array || [];
    options = options || {};
    var isFirstExecution = ko.utils.domData.get(domNode, lastMappingResultDomDataKey) === undefined;
    var lastMappingResult = ko.utils.domData.get(domNode, lastMappingResultDomDataKey) || [];
    var lastArray = ko.utils.arrayMap(lastMappingResult, function (x) { return x.arrayEntry; });
    var editScript = ko.utils.compareArrays(lastArray, array, options['dontLimitMoves']);

    // Build the new mapping result
    var newMappingResult = [];
    var lastMappingResultIndex = 0;
    var newMappingResultIndex = 0;

    var nodesToDelete = [];
    var itemsToProcess = [];
    var itemsForBeforeRemoveCallbacks = [];
    var itemsForMoveCallbacks = [];
    var itemsForAfterAddCallbacks = [];
    var mapData;

    function itemMovedOrRetained(editScriptIndex, oldPosition) {
        mapData = lastMappingResult[oldPosition];
        if (newMappingResultIndex !== oldPosition)
            itemsForMoveCallbacks[editScriptIndex] = mapData;
        // Since updating the index might change the nodes, do so before calling fixUpContinuousNodeArray
        mapData.indexObservable(newMappingResultIndex++);
        ko.utils.fixUpContinuousNodeArray(mapData.mappedNodes, domNode);
        newMappingResult.push(mapData);
        itemsToProcess.push(mapData);
    }

    function callCallback(callback, items) {
        if (callback) {
            for (var i = 0, n = items.length; i &lt; n; i++) {
                if (items[i]) {
                    ko.utils.arrayForEach(items[i].mappedNodes, function(node) {
                        callback(node, i, items[i].arrayEntry);
                    });
                }
            }
        }
    }

    for (var i = 0, editScriptItem, movedIndex; editScriptItem = editScript[i]; i++) {
        movedIndex = editScriptItem['moved'];
        switch (editScriptItem['status']) {
            case "deleted":
                if (movedIndex === undefined) {
                    mapData = lastMappingResult[lastMappingResultIndex];

                    // Stop tracking changes to the mapping for these nodes
                    if (mapData.dependentObservable) {
                        mapData.dependentObservable.dispose();
                        mapData.dependentObservable = undefined;
                    }

                    // Queue these nodes for later removal
                    if (ko.utils.fixUpContinuousNodeArray(mapData.mappedNodes, domNode).length) {
                        if (options['beforeRemove']) {
                            newMappingResult.push(mapData);
                            itemsToProcess.push(mapData);
                            if (mapData.arrayEntry === deletedItemDummyValue) {
                                mapData = null;
                            } else {
                                itemsForBeforeRemoveCallbacks[i] = mapData;
                            }
                        }
                        if (mapData) {
                            nodesToDelete.push.apply(nodesToDelete, mapData.mappedNodes);
                        }
                    }
                }
                lastMappingResultIndex++;
                break;

            case "retained":
                itemMovedOrRetained(i, lastMappingResultIndex++);
                break;

            case "added":
                if (movedIndex !== undefined) {
                    itemMovedOrRetained(i, movedIndex);
                } else {
                    mapData = { arrayEntry: editScriptItem['value'], indexObservable: ko.observable(newMappingResultIndex++) };
                    newMappingResult.push(mapData);
                    itemsToProcess.push(mapData);
                    if (!isFirstExecution)
                        itemsForAfterAddCallbacks[i] = mapData;
                }
                break;
        }
    }

    // Store a copy of the array items we just considered so we can difference it next time
    ko. ...</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.utils.setElementName" id="apidoc.element.knockout.utils.setElementName">
        function <span class="apidocSignatureSpan">knockout.utils.</span>setElementName
        <span class="apidocSignatureSpan">(element, name)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setElementName = function (element, name) {
    element.name = name;

    // Workaround IE 6/7 issue
    // - https://github.com/SteveSanderson/knockout/issues/197
    // - http://www.matts411.com/post/setting_the_name_attribute_in_ie_dom/
    if (ieVersion &lt;= 7) {
        try {
            element.mergeAttributes(document.createElement("&lt;input name='" + element.name + "'/&gt;"), false);
        }
        catch(e) {} // For IE9 with doc mode "IE9 Standards" and browser mode "IE9 Compatibility View"
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.utils.setHtml" id="apidoc.element.knockout.utils.setHtml">
        function <span class="apidocSignatureSpan">knockout.utils.</span>setHtml
        <span class="apidocSignatureSpan">(node, html)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setHtml = function (node, html) {
    ko.utils.emptyDomNode(node);

    // There's no legitimate reason to display a stringified observable without unwrapping it, so we'll unwrap it
    html = ko.utils.unwrapObservable(html);

    if ((html !== null) &amp;&amp; (html !== undefined)) {
        if (typeof html != 'string')
            html = html.toString();

        // jQuery contains a lot of sophisticated code to parse arbitrary HTML fragments,
        // for example &lt;tr&gt; elements which are not normally allowed to exist on their own.
        // If you've referenced jQuery we'll use that rather than duplicating its code.
        if (jQueryInstance) {
            jQueryInstance(node)['html'](html);
        } else {
            // ... otherwise, use KO's own parsing logic.
            var parsedNodes = ko.utils.parseHtmlFragment(html, node.ownerDocument);
            for (var i = 0; i &lt; parsedNodes.length; i++)
                node.appendChild(parsedNodes[i]);
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.utils.setOptionNodeSelectionState" id="apidoc.element.knockout.utils.setOptionNodeSelectionState">
        function <span class="apidocSignatureSpan">knockout.utils.</span>setOptionNodeSelectionState
        <span class="apidocSignatureSpan">(optionNode, isSelected)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setOptionNodeSelectionState = function (optionNode, isSelected) {
    // IE6 sometimes throws "unknown error" if you try to write to .selected directly, whereas Firefox struggles with setAttribute
. Pick one based on browser.
    if (ieVersion &lt; 7)
        optionNode.setAttribute("selected", isSelected);
    else
        optionNode.selected = isSelected;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.utils.setPrototypeOf" id="apidoc.element.knockout.utils.setPrototypeOf">
        function <span class="apidocSignatureSpan">knockout.utils.</span>setPrototypeOf
        <span class="apidocSignatureSpan">(obj, proto)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setPrototypeOf(obj, proto) {
    obj.__proto__ = proto;
    return obj;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.utils.setPrototypeOfOrExtend" id="apidoc.element.knockout.utils.setPrototypeOfOrExtend">
        function <span class="apidocSignatureSpan">knockout.utils.</span>setPrototypeOfOrExtend
        <span class="apidocSignatureSpan">(obj, proto)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function setPrototypeOf(obj, proto) {
    obj.__proto__ = proto;
    return obj;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.utils.setTextContent" id="apidoc.element.knockout.utils.setTextContent">
        function <span class="apidocSignatureSpan">knockout.utils.</span>setTextContent
        <span class="apidocSignatureSpan">(element, textContent)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setTextContent = function (element, textContent) {
    var value = ko.utils.unwrapObservable(textContent);
    if ((value === null) || (value === undefined))
        value = "";

    // We need there to be exactly one child: a text node.
    // If there are no children, more than one, or if it's not a text node,
    // we'll clear everything and create a single text node.
    var innerTextNode = ko.virtualElements.firstChild(element);
    if (!innerTextNode || innerTextNode.nodeType != 3 || ko.virtualElements.nextSibling(innerTextNode)) {
        ko.virtualElements.setDomNodeChildren(element, [element.ownerDocument.createTextNode(value)]);
    } else {
        innerTextNode.data = value;
    }

    ko.utils.forceRefresh(element);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.utils.setTimeout" id="apidoc.element.knockout.utils.setTimeout">
        function <span class="apidocSignatureSpan">knockout.utils.</span>setTimeout
        <span class="apidocSignatureSpan">(handler, timeout)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setTimeout = function (handler, timeout) {
    return setTimeout(ko.utils.catchFunctionErrors(handler), timeout);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.utils.stringStartsWith" id="apidoc.element.knockout.utils.stringStartsWith">
        function <span class="apidocSignatureSpan">knockout.utils.</span>stringStartsWith
        <span class="apidocSignatureSpan">(string, startsWith)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stringStartsWith = function (string, startsWith) {
    string = string || "";
    if (startsWith.length &gt; string.length)
        return false;
    return string.substring(0, startsWith.length) === startsWith;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.utils.stringTrim" id="apidoc.element.knockout.utils.stringTrim">
        function <span class="apidocSignatureSpan">knockout.utils.</span>stringTrim
        <span class="apidocSignatureSpan">(string)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stringTrim = function (string) {
    return string === null || string === undefined ? '' :
        string.trim ?
            string.trim() :
            string.toString().replace(/^[\s\xa0]+|[\s\xa0]+$/g, '');
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.utils.stringifyJson" id="apidoc.element.knockout.utils.stringifyJson">
        function <span class="apidocSignatureSpan">knockout.utils.</span>stringifyJson
        <span class="apidocSignatureSpan">(data, replacer, space)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">stringifyJson = function (data, replacer, space) {   // replacer and space are optional
    if (!JSON || !JSON.stringify)
        throw new Error("Cannot find JSON.stringify(). Some browsers (e.g., IE &lt; 8) don't support it natively, but you can overcome
 this by adding a script reference to json2.js, downloadable from http://www.json.org/json2.js");
    return JSON.stringify(ko.utils.unwrapObservable(data), replacer, space);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.utils.tagNameLower" id="apidoc.element.knockout.utils.tagNameLower">
        function <span class="apidocSignatureSpan">knockout.utils.</span>tagNameLower
        <span class="apidocSignatureSpan">(element)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">tagNameLower = function (element) {
    // For HTML elements, tagName will always be upper case; for XHTML elements, it'll be lower case.
    // Possible future optimization: If we know it's an element from an XHTML document (not HTML),
    // we don't need to do the .toLowerCase() as it will always be lower case anyway.
    return element &amp;&amp; element.tagName &amp;&amp; element.tagName.toLowerCase();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.utils.toggleDomNodeCssClass" id="apidoc.element.knockout.utils.toggleDomNodeCssClass">
        function <span class="apidocSignatureSpan">knockout.utils.</span>toggleDomNodeCssClass
        <span class="apidocSignatureSpan">(node, classNames, shouldHaveClass)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function toggleDomNodeCssClass(node, classNames, shouldHaveClass) {
    var addOrRemoveFn;
    if (classNames) {
        if (typeof node.classList === 'object') {
            addOrRemoveFn = node.classList[shouldHaveClass ? 'add' : 'remove'];
            ko.utils.arrayForEach(classNames.match(cssClassNameRegex), function(className) {
                addOrRemoveFn.call(node.classList, className);
            });
        } else if (typeof node.className['baseVal'] === 'string') {
            // SVG tag .classNames is an SVGAnimatedString instance
            toggleObjectClassPropertyString(node.className, 'baseVal', classNames, shouldHaveClass);
        } else {
            // node.className ought to be a string.
            toggleObjectClassPropertyString(node, 'className', classNames, shouldHaveClass);
        }
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.utils.triggerEvent" id="apidoc.element.knockout.utils.triggerEvent">
        function <span class="apidocSignatureSpan">knockout.utils.</span>triggerEvent
        <span class="apidocSignatureSpan">(element, eventType)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">triggerEvent = function (element, eventType) {
    if (!(element &amp;&amp; element.nodeType))
        throw new Error("element must be a DOM node when calling triggerEvent");

    // For click events on checkboxes and radio buttons, jQuery toggles the element checked state *after* the
    // event handler runs instead of *before*. (This was fixed in 1.9 for checkboxes but not for radio buttons.)
    // IE doesn't change the checked state when you trigger the click event using "fireEvent".
    // In both cases, we'll use the click method instead.
    var useClickWorkaround = isClickOnCheckableElement(element, eventType);

    if (!ko.options['useOnlyNativeEvents'] &amp;&amp; jQueryInstance &amp;&amp; !useClickWorkaround) {
        jQueryInstance(element)['trigger'](eventType);
    } else if (typeof document.createEvent == "function") {
        if (typeof element.dispatchEvent == "function") {
            var eventCategory = knownEventTypesByEventName[eventType] || "HTMLEvents";
            var event = document.createEvent(eventCategory);
            event.initEvent(eventType, true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, element);
            element.dispatchEvent(event);
        }
        else
            throw new Error("The supplied element doesn't support dispatchEvent");
    } else if (useClickWorkaround &amp;&amp; element.click) {
        element.click();
    } else if (typeof element.fireEvent != "undefined") {
        element.fireEvent("on" + eventType);
    } else {
        throw new Error("Browser doesn't support triggering events");
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.utils.unwrapObservable" id="apidoc.element.knockout.utils.unwrapObservable">
        function <span class="apidocSignatureSpan">knockout.utils.</span>unwrapObservable
        <span class="apidocSignatureSpan">(value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">unwrapObservable = function (value) {
    return ko.isObservable(value) ? value() : value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.knockout.utils.domData" id="apidoc.module.knockout.utils.domData">module knockout.utils.domData</a></h1>


    <h2>
        <a href="#apidoc.element.knockout.utils.domData.clear" id="apidoc.element.knockout.utils.domData.clear">
        function <span class="apidocSignatureSpan">knockout.utils.domData.</span>clear
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clear = function (node) {
    var dataStoreKey = node[dataStoreKeyExpandoPropertyName];
    if (dataStoreKey) {
        delete dataStore[dataStoreKey];
        node[dataStoreKeyExpandoPropertyName] = null;
        return true; // Exposing "did clean" flag purely so specs can infer whether things have been cleaned up as intended
    }
    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.utils.domData.get" id="apidoc.element.knockout.utils.domData.get">
        function <span class="apidocSignatureSpan">knockout.utils.domData.</span>get
        <span class="apidocSignatureSpan">(node, key)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">get = function (node, key) {
    var allDataForNode = getAll(node, false);
    return allDataForNode === undefined ? undefined : allDataForNode[key];
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.utils.domData.nextKey" id="apidoc.element.knockout.utils.domData.nextKey">
        function <span class="apidocSignatureSpan">knockout.utils.domData.</span>nextKey
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nextKey = function () {
    return (uniqueId++) + dataStoreKeyExpandoPropertyName;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.utils.domData.set" id="apidoc.element.knockout.utils.domData.set">
        function <span class="apidocSignatureSpan">knockout.utils.domData.</span>set
        <span class="apidocSignatureSpan">(node, key, value)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">set = function (node, key, value) {
    if (value === undefined) {
        // Make sure we don't actually create a new domData key if we are actually deleting a value
        if (getAll(node, false) === undefined)
            return;
    }
    var allDataForNode = getAll(node, true);
    allDataForNode[key] = value;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.knockout.utils.domNodeDisposal" id="apidoc.module.knockout.utils.domNodeDisposal">module knockout.utils.domNodeDisposal</a></h1>


    <h2>
        <a href="#apidoc.element.knockout.utils.domNodeDisposal.addDisposeCallback" id="apidoc.element.knockout.utils.domNodeDisposal.addDisposeCallback">
        function <span class="apidocSignatureSpan">knockout.utils.domNodeDisposal.</span>addDisposeCallback
        <span class="apidocSignatureSpan">(node, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">addDisposeCallback = function (node, callback) {
    if (typeof callback != "function")
        throw new Error("Callback must be a function");
    getDisposeCallbacksCollection(node, true).push(callback);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.utils.domNodeDisposal.cleanExternalData" id="apidoc.element.knockout.utils.domNodeDisposal.cleanExternalData">
        function <span class="apidocSignatureSpan">knockout.utils.domNodeDisposal.</span>cleanExternalData
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cleanExternalData = function (node) {
    // Special support for jQuery here because it's so commonly used.
    // Many jQuery plugins (including jquery.tmpl) store data using jQuery's equivalent of domData
    // so notify it to tear down any resources associated with the node &amp; descendants here.
    if (jQueryInstance &amp;&amp; (typeof jQueryInstance['cleanData'] == "function"))
        jQueryInstance['cleanData']([node]);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.utils.domNodeDisposal.cleanNode" id="apidoc.element.knockout.utils.domNodeDisposal.cleanNode">
        function <span class="apidocSignatureSpan">knockout.utils.domNodeDisposal.</span>cleanNode
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">cleanNode = function (node) {
    // First clean this node, where applicable
    if (cleanableNodeTypes[node.nodeType]) {
        cleanSingleNode(node);

        // ... then its descendants, where applicable
        if (cleanableNodeTypesWithDescendants[node.nodeType]) {
            // Clone the descendants list in case it changes during iteration
            var descendants = [];
            ko.utils.arrayPushAll(descendants, node.getElementsByTagName("*"));
            for (var i = 0, j = descendants.length; i &lt; j; i++)
                cleanSingleNode(descendants[i]);
        }
    }
    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.utils.domNodeDisposal.removeDisposeCallback" id="apidoc.element.knockout.utils.domNodeDisposal.removeDisposeCallback">
        function <span class="apidocSignatureSpan">knockout.utils.domNodeDisposal.</span>removeDisposeCallback
        <span class="apidocSignatureSpan">(node, callback)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeDisposeCallback = function (node, callback) {
    var callbacksCollection = getDisposeCallbacksCollection(node, false);
    if (callbacksCollection) {
        ko.utils.arrayRemoveItem(callbacksCollection, callback);
        if (callbacksCollection.length == 0)
            destroyCallbacksCollection(node);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.utils.domNodeDisposal.removeNode" id="apidoc.element.knockout.utils.domNodeDisposal.removeNode">
        function <span class="apidocSignatureSpan">knockout.utils.domNodeDisposal.</span>removeNode
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">removeNode = function (node) {
    ko.cleanNode(node);
    if (node.parentNode)
        node.parentNode.removeChild(node);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.knockout.virtualElements" id="apidoc.module.knockout.virtualElements">module knockout.virtualElements</a></h1>


    <h2>
        <a href="#apidoc.element.knockout.virtualElements.childNodes" id="apidoc.element.knockout.virtualElements.childNodes">
        function <span class="apidocSignatureSpan">knockout.virtualElements.</span>childNodes
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">childNodes = function (node) {
    return isStartComment(node) ? getVirtualChildren(node) : node.childNodes;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.virtualElements.emptyNode" id="apidoc.element.knockout.virtualElements.emptyNode">
        function <span class="apidocSignatureSpan">knockout.virtualElements.</span>emptyNode
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">emptyNode = function (node) {
    if (!isStartComment(node))
        ko.utils.emptyDomNode(node);
    else {
        var virtualChildren = ko.virtualElements.childNodes(node);
        for (var i = 0, j = virtualChildren.length; i &lt; j; i++)
            ko.removeNode(virtualChildren[i]);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.virtualElements.firstChild" id="apidoc.element.knockout.virtualElements.firstChild">
        function <span class="apidocSignatureSpan">knockout.virtualElements.</span>firstChild
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">firstChild = function (node) {
    if (!isStartComment(node))
        return node.firstChild;
    if (!node.nextSibling || isEndComment(node.nextSibling))
        return null;
    return node.nextSibling;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.virtualElements.hasBindingValue" id="apidoc.element.knockout.virtualElements.hasBindingValue">
        function <span class="apidocSignatureSpan">knockout.virtualElements.</span>hasBindingValue
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function isStartComment(node) {
    return (node.nodeType == 8) &amp;&amp; startCommentRegex.test(commentNodesHaveTextProperty ? node.text : node.nodeValue);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.virtualElements.insertAfter" id="apidoc.element.knockout.virtualElements.insertAfter">
        function <span class="apidocSignatureSpan">knockout.virtualElements.</span>insertAfter
        <span class="apidocSignatureSpan">(containerNode, nodeToInsert, insertAfterNode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">insertAfter = function (containerNode, nodeToInsert, insertAfterNode) {
    if (!insertAfterNode) {
        ko.virtualElements.prepend(containerNode, nodeToInsert);
    } else if (!isStartComment(containerNode)) {
        // Insert after insertion point
        if (insertAfterNode.nextSibling)
            containerNode.insertBefore(nodeToInsert, insertAfterNode.nextSibling);
        else
            containerNode.appendChild(nodeToInsert);
    } else {
        // Children of start comments must always have a parent and at least one following sibling (the end comment)
        containerNode.parentNode.insertBefore(nodeToInsert, insertAfterNode.nextSibling);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.virtualElements.nextSibling" id="apidoc.element.knockout.virtualElements.nextSibling">
        function <span class="apidocSignatureSpan">knockout.virtualElements.</span>nextSibling
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">nextSibling = function (node) {
    if (isStartComment(node))
        node = getMatchingEndComment(node);
    if (node.nextSibling &amp;&amp; isEndComment(node.nextSibling))
        return null;
    return node.nextSibling;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.virtualElements.normaliseVirtualElementDomStructure" id="apidoc.element.knockout.virtualElements.normaliseVirtualElementDomStructure">
        function <span class="apidocSignatureSpan">knockout.virtualElements.</span>normaliseVirtualElementDomStructure
        <span class="apidocSignatureSpan">(elementVerified)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">normaliseVirtualElementDomStructure = function (elementVerified) {
    // Workaround for https://github.com/SteveSanderson/knockout/issues/155
    // (IE &lt;= 8 or IE 9 quirks mode parses your HTML weirdly, treating closing &lt;/li&gt; tags as if they don't exist, thereby moving
 comment nodes
    // that are direct descendants of &lt;ul&gt; into the preceding &lt;li&gt;)
    if (!htmlTagsWithOptionallyClosingChildren[ko.utils.tagNameLower(elementVerified)])
        return;

    // Scan immediate children to see if they contain unbalanced comment tags. If they do, those comment tags
    // must be intended to appear *after* that child, so move them there.
    var childNode = elementVerified.firstChild;
    if (childNode) {
        do {
            if (childNode.nodeType === 1) {
                var unbalancedTags = getUnbalancedChildTags(childNode);
                if (unbalancedTags) {
                    // Fix up the DOM by moving the unbalanced tags to where they most likely were intended to be placed - *after
* the child
                    var nodeToInsertBefore = childNode.nextSibling;
                    for (var i = 0; i &lt; unbalancedTags.length; i++) {
                        if (nodeToInsertBefore)
                            elementVerified.insertBefore(unbalancedTags[i], nodeToInsertBefore);
                        else
                            elementVerified.appendChild(unbalancedTags[i]);
                    }
                }
            }
        } while (childNode = childNode.nextSibling);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.virtualElements.prepend" id="apidoc.element.knockout.virtualElements.prepend">
        function <span class="apidocSignatureSpan">knockout.virtualElements.</span>prepend
        <span class="apidocSignatureSpan">(containerNode, nodeToPrepend)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">prepend = function (containerNode, nodeToPrepend) {
    if (!isStartComment(containerNode)) {
        if (containerNode.firstChild)
            containerNode.insertBefore(nodeToPrepend, containerNode.firstChild);
        else
            containerNode.appendChild(nodeToPrepend);
    } else {
        // Start comments must always have a parent and at least one following sibling (the end comment)
        containerNode.parentNode.insertBefore(nodeToPrepend, containerNode.nextSibling);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.virtualElements.setDomNodeChildren" id="apidoc.element.knockout.virtualElements.setDomNodeChildren">
        function <span class="apidocSignatureSpan">knockout.virtualElements.</span>setDomNodeChildren
        <span class="apidocSignatureSpan">(node, childNodes)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">setDomNodeChildren = function (node, childNodes) {
    if (!isStartComment(node))
        ko.utils.setDomNodeChildren(node, childNodes);
    else {
        ko.virtualElements.emptyNode(node);
        var endCommentNode = node.nextSibling; // Must be the next sibling, as we just emptied the children
        for (var i = 0, j = childNodes.length; i &lt; j; i++)
            endCommentNode.parentNode.insertBefore(childNodes[i], endCommentNode);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.knockout.virtualElements.virtualNodeBindingValue" id="apidoc.element.knockout.virtualElements.virtualNodeBindingValue">
        function <span class="apidocSignatureSpan">knockout.virtualElements.</span>virtualNodeBindingValue
        <span class="apidocSignatureSpan">(node)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">virtualNodeBindingValue = function (node) {
    var regexMatch = (commentNodesHaveTextProperty ? node.text : node.nodeValue).match(startCommentRegex);
    return regexMatch ? regexMatch[1] : null;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
</body></html>